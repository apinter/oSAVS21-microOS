import {
  js_yaml_default
} from "./chunk-A3KXTWJK.js";
import "./chunk-IHTDASF6.js";

// node_modules/@slidev/parser/dist/chunk-WPUFEJRV.mjs
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __reExport = (target, module, desc) => {
  if (module && typeof module === "object" || typeof module === "function") {
    for (let key of __getOwnPropNames(module))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module) => {
  return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
};
var require_dist = __commonJS({
  "../../node_modules/.pnpm/@antfu+utils@0.2.4/node_modules/@antfu/utils/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function clamp(n, min, max) {
      return Math.min(max, Math.max(min, n));
    }
    function sum(...args) {
      return flattenArrayable(args).reduce((a, b) => a + b, 0);
    }
    function toArray2(array) {
      array = array || [];
      if (Array.isArray(array))
        return array;
      return [array];
    }
    function flattenArrayable(array) {
      return toArray2(array).flat(1);
    }
    function mergeArrayable(...args) {
      return args.flatMap((i) => toArray2(i));
    }
    function partition(array, filter) {
      const pass = [];
      const fail = [];
      array.forEach((e, idx, arr) => (filter(e, idx, arr) ? pass : fail).push(e));
      return [pass, fail];
    }
    function uniq3(array) {
      return Array.from(new Set(array));
    }
    function last(array) {
      return at(array, -1);
    }
    function remove(array, value) {
      if (!array)
        return false;
      const index = array.indexOf(value);
      if (index >= 0) {
        array.splice(index, 1);
        return true;
      }
      return false;
    }
    function at(array, index) {
      const len = array.length;
      if (!len)
        return void 0;
      if (index < 0)
        index += len;
      return array[index];
    }
    function range2(...args) {
      let start, stop, step;
      if (args.length === 1) {
        start = 0;
        step = 1;
        [stop] = args;
      } else {
        [start, stop, step = 1] = args;
      }
      const arr = [];
      let current = start;
      while (current < stop) {
        arr.push(current);
        current += step || 1;
      }
      return arr;
    }
    function move(arr, from, to) {
      arr.splice(to, 0, arr.splice(from, 1)[0]);
      return arr;
    }
    function clampArrayRange(n, arr) {
      return clamp(n, 0, arr.length - 1);
    }
    var assert = (condition, message) => {
      if (!condition)
        throw new Error(message);
    };
    var toString2 = Object.prototype.toString;
    var noop = () => {
    };
    function notNullish(v) {
      return v != null;
    }
    function noNull(v) {
      return v !== null;
    }
    function notUndefined(v) {
      return v !== void 0;
    }
    function isTruthy2(v) {
      return Boolean(v);
    }
    var isBrowser = typeof window !== "undefined";
    var isDef = (val) => typeof val !== "undefined";
    var isBoolean = (val) => typeof val === "boolean";
    var isFunction = (val) => typeof val === "function";
    var isNumber2 = (val) => typeof val === "number";
    var isString = (val) => typeof val === "string";
    var isObject2 = (val) => toString.call(val) === "[object Object]";
    var isWindow = (val) => typeof window !== "undefined" && toString.call(val) === "[object Window]";
    function slash(str) {
      return str.replace(/\\/g, "/");
    }
    function ensurePrefix(prefix, str) {
      if (!str.startsWith(prefix))
        return prefix + str;
      return str;
    }
    var timestamp = () => +Date.now();
    function batchInvoke(functions) {
      functions.forEach((fn) => fn && fn());
    }
    function invoke(fn) {
      return fn();
    }
    function tap(value, callback) {
      callback(value);
      return value;
    }
    function objectMap2(obj, fn) {
      return Object.fromEntries(Object.entries(obj).map(([k, v]) => fn(k, v)).filter(notNullish));
    }
    function isKeyOf(obj, k) {
      return k in obj;
    }
    function objectKeys(obj) {
      return Object.keys(obj);
    }
    function objectEntries(obj) {
      return Object.entries(obj);
    }
    function deepMerge(target, ...sources) {
      if (!sources.length)
        return target;
      const source = sources.shift();
      if (source === void 0)
        return target;
      if (isMergableObject(target) && isMergableObject(source)) {
        objectKeys(source).forEach((key) => {
          if (isMergableObject(source[key])) {
            if (!target[key])
              target[key] = {};
            deepMerge(target[key], source[key]);
          } else {
            target[key] = source[key];
          }
        });
      }
      return deepMerge(target, ...sources);
    }
    function isMergableObject(item) {
      return isObject2(item) && !Array.isArray(item);
    }
    function objectPick(obj, keys, omitUndefined = false) {
      return keys.reduce((n, k) => {
        if (k in obj) {
          if (!omitUndefined || !obj[k] === void 0)
            n[k] = obj[k];
        }
        return n;
      }, {});
    }
    function clearUndefined(obj) {
      Object.keys(obj).forEach((key) => obj[key] === void 0 ? delete obj[key] : {});
      return obj;
    }
    function hasOwnProperty(obj, v) {
      if (obj == null)
        return false;
      return Object.prototype.hasOwnProperty.call(obj, v);
    }
    function createSingletonPromise(fn) {
      let _promise;
      function wrapper() {
        if (!_promise)
          _promise = fn();
        return _promise;
      }
      wrapper.reset = async () => {
        const _prev = _promise;
        _promise = void 0;
        if (_prev)
          await _prev;
      };
      return wrapper;
    }
    function sleep(ms, callback) {
      return new Promise((resolve) => setTimeout(async () => {
        await (callback == null ? void 0 : callback());
        resolve();
      }, ms));
    }
    function throttle(delay, noTrailing, callback, debounceMode) {
      var timeoutID;
      var cancelled = false;
      var lastExec = 0;
      function clearExistingTimeout() {
        if (timeoutID) {
          clearTimeout(timeoutID);
        }
      }
      function cancel() {
        clearExistingTimeout();
        cancelled = true;
      }
      if (typeof noTrailing !== "boolean") {
        debounceMode = callback;
        callback = noTrailing;
        noTrailing = void 0;
      }
      function wrapper() {
        for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
          arguments_[_key] = arguments[_key];
        }
        var self = this;
        var elapsed = Date.now() - lastExec;
        if (cancelled) {
          return;
        }
        function exec() {
          lastExec = Date.now();
          callback.apply(self, arguments_);
        }
        function clear() {
          timeoutID = void 0;
        }
        if (debounceMode && !timeoutID) {
          exec();
        }
        clearExistingTimeout();
        if (debounceMode === void 0 && elapsed > delay) {
          exec();
        } else if (noTrailing !== true) {
          timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === void 0 ? delay - elapsed : delay);
        }
      }
      wrapper.cancel = cancel;
      return wrapper;
    }
    function debounce(delay, atBegin, callback) {
      return callback === void 0 ? throttle(delay, atBegin, false) : throttle(delay, callback, atBegin !== false);
    }
    exports.assert = assert;
    exports.at = at;
    exports.batchInvoke = batchInvoke;
    exports.clamp = clamp;
    exports.clampArrayRange = clampArrayRange;
    exports.clearUndefined = clearUndefined;
    exports.createSingletonPromise = createSingletonPromise;
    exports.debounce = debounce;
    exports.deepMerge = deepMerge;
    exports.ensurePrefix = ensurePrefix;
    exports.flattenArrayable = flattenArrayable;
    exports.hasOwnProperty = hasOwnProperty;
    exports.invoke = invoke;
    exports.isBoolean = isBoolean;
    exports.isBrowser = isBrowser;
    exports.isDef = isDef;
    exports.isFunction = isFunction;
    exports.isKeyOf = isKeyOf;
    exports.isNumber = isNumber2;
    exports.isObject = isObject2;
    exports.isString = isString;
    exports.isTruthy = isTruthy2;
    exports.isWindow = isWindow;
    exports.last = last;
    exports.mergeArrayable = mergeArrayable;
    exports.move = move;
    exports.noNull = noNull;
    exports.noop = noop;
    exports.notNullish = notNullish;
    exports.notUndefined = notUndefined;
    exports.objectEntries = objectEntries;
    exports.objectKeys = objectKeys;
    exports.objectMap = objectMap2;
    exports.objectPick = objectPick;
    exports.partition = partition;
    exports.range = range2;
    exports.remove = remove;
    exports.slash = slash;
    exports.sleep = sleep;
    exports.sum = sum;
    exports.tap = tap;
    exports.throttle = throttle;
    exports.timestamp = timestamp;
    exports.toArray = toArray2;
    exports.toString = toString2;
    exports.uniq = uniq3;
  }
});
var import_utils3 = __toModule(require_dist());
var import_utils = __toModule(require_dist());
function parseRangeString(total, rangeStr) {
  if (!rangeStr || rangeStr === "all" || rangeStr === "*")
    return (0, import_utils.range)(1, total + 1);
  const pages = [];
  for (const part of rangeStr.split(/[,;]/g)) {
    if (!part.includes("-")) {
      pages.push(+part);
    } else {
      const [start, end] = part.split("-", 2);
      pages.push(...(0, import_utils.range)(+start, !end ? total + 1 : +end + 1));
    }
  }
  return (0, import_utils.uniq)(pages).filter((i) => i <= total).sort((a, b) => a - b);
}
function parseAspectRatio(str) {
  if ((0, import_utils.isNumber)(str))
    return str;
  if (!isNaN(+str))
    return +str;
  const [wStr = "", hStr = ""] = str.split(/[:\/x\|]/);
  const w = parseFloat(wStr.trim());
  const h = parseFloat(hStr.trim());
  if (isNaN(w) || isNaN(h) || h === 0)
    throw new Error(`Invalid aspect ratio "${str}"`);
  return w / h;
}
function resolveConfig(headmatter, themeMeta = {}) {
  var _a, _b;
  const themeHightlighter = ["prism", "shiki"].includes(themeMeta.highlighter || "") ? themeMeta.highlighter : void 0;
  const themeColorSchema = ["light", "dark"].includes(themeMeta.colorSchema || "") ? themeMeta.colorSchema : void 0;
  const defaultConfig = {
    theme: "default",
    title: "Slidev",
    titleTemplate: "%s - Slidev",
    remoteAssets: true,
    monaco: "dev",
    download: false,
    info: false,
    highlighter: themeHightlighter || "prism",
    lineNumbers: false,
    colorSchema: themeColorSchema || "auto",
    routerMode: "history",
    aspectRatio: 16 / 9,
    canvasWidth: 980,
    selectable: false,
    themeConfig: {},
    fonts: {}
  };
  const config = __spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, defaultConfig), themeMeta.defaults), headmatter.config), headmatter), {
    fonts: resolveFonts(__spreadValues(__spreadValues(__spreadValues({}, (_a = themeMeta.defaults) == null ? void 0 : _a.fonts), (_b = headmatter.config) == null ? void 0 : _b.fonts), headmatter == null ? void 0 : headmatter.fonts))
  });
  if (config.colorSchema !== "dark" && config.colorSchema !== "light")
    config.colorSchema = "auto";
  if (themeColorSchema && config.colorSchema === "auto")
    config.colorSchema = themeColorSchema;
  config.aspectRatio = parseAspectRatio(config.aspectRatio);
  if (themeColorSchema && config.colorSchema !== themeColorSchema)
    console.warn(`[slidev] Color schema "${config.colorSchema}" does not supported by the theme`);
  if (themeHightlighter && config.highlighter !== themeHightlighter)
    console.warn(`[slidev] Syntax highlighter "${config.highlighter}" does not supported by the theme`);
  return config;
}
function stringify(data) {
  return `${data.slides.map((slide, idx) => stringifySlide(slide.inline || slide, idx)).join("\n").trim()}
`;
}
function filterDisabled(data) {
  data.slides = data.slides.filter((i) => {
    var _a;
    return !((_a = i.frontmatter) == null ? void 0 : _a.disabled);
  });
  return data;
}
function stringifySlide(data, idx = 0) {
  if (data.raw == null)
    prettifySlide(data);
  return data.raw.startsWith("---") || idx === 0 ? data.raw : `---
${data.raw.startsWith("\n") ? data.raw : `
${data.raw}`}`;
}
function prettifySlide(data) {
  data.content = `
${data.content.trim()}
`;
  data.raw = Object.keys(data.frontmatter || {}).length ? `---
${js_yaml_default.dump(data.frontmatter).trim()}
---
${data.content}` : data.content;
  if (data.note)
    data.raw += `
<!--
${data.note.trim()}
-->
`;
  else
    data.raw += "\n";
  return data;
}
function prettify(data) {
  data.slides.forEach(prettifySlide);
  return data;
}
function matter(code) {
  let data = {};
  const content = code.replace(/^---.*\r?\n([\s\S]*?)---/, (_, d) => {
    data = js_yaml_default.load(d);
    if (!(0, import_utils3.isObject)(data))
      data = {};
    return "";
  });
  return { data, content };
}
function detectFeatures(code) {
  return {
    katex: !!code.match(/\$.*?\$/) || !!code.match(/$\$\$/),
    monaco: !!code.match(/{monaco.*}/),
    tweet: !!code.match(/<Tweet\b/),
    mermaid: !!code.match(/^```mermaid/m)
  };
}
function parseSlide(raw) {
  var _a, _b;
  const result = matter(raw);
  let note;
  const frontmatter = result.data || {};
  const content = result.content.trim().replace(/<!--([\s\S]*)-->$/g, (_, v = "") => {
    note = v.trim();
    return "";
  });
  const title = frontmatter.title || frontmatter.name || ((_b = (_a = content.match(/^#+ (.*)$/m)) == null ? void 0 : _a[1]) == null ? void 0 : _b.trim());
  return {
    raw,
    title,
    content,
    frontmatter,
    note
  };
}
function parse(markdown, filepath, themeMeta) {
  var _a, _b;
  const lines = markdown.split(/\r?\n/g);
  const slides = [];
  let start = 0;
  function slice(end) {
    if (start === end)
      return;
    const raw = lines.slice(start, end).join("\n");
    slides.push(__spreadProps(__spreadValues({}, parseSlide(raw)), {
      index: slides.length,
      start,
      end
    }));
    start = end + 1;
  }
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trimRight();
    if (line.match(/^---+/)) {
      slice(i);
      const next = lines[i + 1];
      if (line.match(/^---([^-].*)?$/) && !(next == null ? void 0 : next.match(/^\s*$/))) {
        start = i;
        for (i += 1; i < lines.length; i++) {
          if (lines[i].trimRight().match(/^---$/))
            break;
        }
      }
    } else if (line.startsWith("```")) {
      for (i += 1; i < lines.length; i++) {
        if (lines[i].startsWith("```"))
          break;
      }
    }
  }
  if (start <= lines.length - 1)
    slice(lines.length);
  const headmatter = ((_a = slides[0]) == null ? void 0 : _a.frontmatter) || {};
  headmatter.title = headmatter.title || ((_b = slides[0]) == null ? void 0 : _b.title);
  const config = resolveConfig(headmatter, themeMeta);
  const features = detectFeatures(markdown);
  return {
    raw: markdown,
    filepath,
    slides,
    config,
    features,
    headmatter,
    themeMeta
  };
}
function resolveFonts(fonts = {}) {
  const {
    fallbacks = true,
    italic = false,
    provider = "google"
  } = fonts;
  let sans = (0, import_utils3.toArray)(fonts.sans).flatMap((i) => i.split(/,\s*/g)).map((i) => i.trim());
  let serif = (0, import_utils3.toArray)(fonts.serif).flatMap((i) => i.split(/,\s*/g)).map((i) => i.trim());
  let mono = (0, import_utils3.toArray)(fonts.mono).flatMap((i) => i.split(/,\s*/g)).map((i) => i.trim());
  const weights = (0, import_utils3.toArray)(fonts.weights || "200,400,600").flatMap((i) => i.toString().split(/,\s*/g)).map((i) => i.trim());
  const custom = (0, import_utils3.toArray)(fonts.custom).flatMap((i) => i.split(/,\s*/g)).map((i) => i.trim());
  const local = (0, import_utils3.toArray)(fonts.local).flatMap((i) => i.split(/,\s*/g)).map((i) => i.trim());
  const webfonts = fonts.webfonts ? fonts.webfonts : fallbacks ? (0, import_utils3.uniq)([...sans, ...serif, ...mono, ...custom]) : [];
  webfonts.filter((i) => local.includes(i));
  function toQuoted(font) {
    if (/^(['"]).*\1$/.test(font))
      return font;
    return `"${font}"`;
  }
  if (fallbacks) {
    sans = (0, import_utils3.uniq)([
      ...sans.map(toQuoted),
      "ui-sans-serif",
      "system-ui",
      "-apple-system",
      "BlinkMacSystemFont",
      '"Segoe UI"',
      "Roboto",
      '"Helvetica Neue"',
      "Arial",
      '"Noto Sans"',
      "sans-serif",
      '"Apple Color Emoji"',
      '"Segoe UI Emoji"',
      '"Segoe UI Symbol"',
      '"Noto Color Emoji"'
    ]);
    serif = (0, import_utils3.uniq)([
      ...serif.map(toQuoted),
      "ui-serif",
      "Georgia",
      "Cambria",
      '"Times New Roman"',
      "Times",
      "serif"
    ]);
    mono = (0, import_utils3.uniq)([
      ...mono.map(toQuoted),
      "ui-monospace",
      "SFMono-Regular",
      "Menlo",
      "Monaco",
      "Consolas",
      '"Liberation Mono"',
      '"Courier New"',
      "monospace"
    ]);
  }
  return {
    sans,
    serif,
    mono,
    webfonts,
    provider,
    local,
    italic,
    weights
  };
}
function mergeFeatureFlags(a, b) {
  return (0, import_utils3.objectMap)(a, (k, v) => [k, v || b[k]]);
}
function scanMonacoModules(md) {
  const typeModules = new Set();
  md.replace(/^```(\w+?)\s*{monaco([\w:,-]*)}[\s\n]*([\s\S]+?)^```/mg, (full, lang = "ts", options, code) => {
    options = options || "";
    lang = lang.trim();
    if (lang === "ts" || lang === "typescript") {
      Array.from(code.matchAll(/\s+from\s+(["'])([\/\w@-]+)\1/g)).map((i) => i[2]).filter(import_utils3.isTruthy).map((i) => typeModules.add(i));
    }
    return "";
  });
  return Array.from(typeModules);
}
export {
  detectFeatures,
  filterDisabled,
  mergeFeatureFlags,
  parse,
  parseAspectRatio,
  parseRangeString,
  parseSlide,
  prettify,
  prettifySlide,
  resolveConfig,
  resolveFonts,
  scanMonacoModules,
  stringify,
  stringifySlide
};
//# sourceMappingURL=@slidev_parser.js.map
