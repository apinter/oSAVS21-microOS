"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault2(obj) { return obj && obj.__esModule ? obj : { default: obj }; }




var _chunkKRCSYS75js = require('./chunk-KRCSYS75.js');

// ../../node_modules/.pnpm/@antfu+ni@0.7.0/node_modules/@antfu/ni/dist/chunk-JBT3DO44.js
var require_chunk_JBT3DO44 = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/@antfu+ni@0.7.0/node_modules/@antfu/ni/dist/chunk-JBT3DO44.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
    var __propIsEnum = Object.prototype.propertyIsEnumerable;
    var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __objSpread = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
          if (__propIsEnum.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
        }
      return a;
    };
    var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
    var __objRest = (source, exclude2) => {
      var target = {};
      for (var prop in source)
        if (__hasOwnProp.call(source, prop) && exclude2.indexOf(prop) < 0)
          target[prop] = source[prop];
      if (source != null && __getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(source)) {
          if (exclude2.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
            target[prop] = source[prop];
        }
      return target;
    };
    var __commonJS2 = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
    var __reExport = (target, module2, desc) => {
      if (module2 && typeof module2 === "object" || typeof module2 === "function") {
        for (let key of __getOwnPropNames(module2))
          if (!__hasOwnProp.call(target, key) && key !== "default")
            __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
      }
      return target;
    };
    var __toModule2 = (module2) => {
      return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
    };
    var require_kleur = __commonJS2((exports2, module2) => {
      "use strict";
      var { FORCE_COLOR, NODE_DISABLE_COLORS, TERM } = process.env;
      var $ = {
        enabled: !NODE_DISABLE_COLORS && TERM !== "dumb" && FORCE_COLOR !== "0",
        reset: init(0, 0),
        bold: init(1, 22),
        dim: init(2, 22),
        italic: init(3, 23),
        underline: init(4, 24),
        inverse: init(7, 27),
        hidden: init(8, 28),
        strikethrough: init(9, 29),
        black: init(30, 39),
        red: init(31, 39),
        green: init(32, 39),
        yellow: init(33, 39),
        blue: init(34, 39),
        magenta: init(35, 39),
        cyan: init(36, 39),
        white: init(37, 39),
        gray: init(90, 39),
        grey: init(90, 39),
        bgBlack: init(40, 49),
        bgRed: init(41, 49),
        bgGreen: init(42, 49),
        bgYellow: init(43, 49),
        bgBlue: init(44, 49),
        bgMagenta: init(45, 49),
        bgCyan: init(46, 49),
        bgWhite: init(47, 49)
      };
      function run22(arr, str) {
        let i = 0, tmp, beg = "", end = "";
        for (; i < arr.length; i++) {
          tmp = arr[i];
          beg += tmp.open;
          end += tmp.close;
          if (str.includes(tmp.close)) {
            str = str.replace(tmp.rgx, tmp.close + tmp.open);
          }
        }
        return beg + str + end;
      }
      function chain(has, keys) {
        let ctx = { has, keys };
        ctx.reset = $.reset.bind(ctx);
        ctx.bold = $.bold.bind(ctx);
        ctx.dim = $.dim.bind(ctx);
        ctx.italic = $.italic.bind(ctx);
        ctx.underline = $.underline.bind(ctx);
        ctx.inverse = $.inverse.bind(ctx);
        ctx.hidden = $.hidden.bind(ctx);
        ctx.strikethrough = $.strikethrough.bind(ctx);
        ctx.black = $.black.bind(ctx);
        ctx.red = $.red.bind(ctx);
        ctx.green = $.green.bind(ctx);
        ctx.yellow = $.yellow.bind(ctx);
        ctx.blue = $.blue.bind(ctx);
        ctx.magenta = $.magenta.bind(ctx);
        ctx.cyan = $.cyan.bind(ctx);
        ctx.white = $.white.bind(ctx);
        ctx.gray = $.gray.bind(ctx);
        ctx.grey = $.grey.bind(ctx);
        ctx.bgBlack = $.bgBlack.bind(ctx);
        ctx.bgRed = $.bgRed.bind(ctx);
        ctx.bgGreen = $.bgGreen.bind(ctx);
        ctx.bgYellow = $.bgYellow.bind(ctx);
        ctx.bgBlue = $.bgBlue.bind(ctx);
        ctx.bgMagenta = $.bgMagenta.bind(ctx);
        ctx.bgCyan = $.bgCyan.bind(ctx);
        ctx.bgWhite = $.bgWhite.bind(ctx);
        return ctx;
      }
      function init(open, close) {
        let blk = {
          open: `[${open}m`,
          close: `[${close}m`,
          rgx: new RegExp(`\\x1b\\[${close}m`, "g")
        };
        return function(txt) {
          if (this !== void 0 && this.has !== void 0) {
            this.has.includes(open) || (this.has.push(open), this.keys.push(blk));
            return txt === void 0 ? this : $.enabled ? run22(this.keys, txt + "") : txt + "";
          }
          return txt === void 0 ? chain([open], [blk]) : $.enabled ? run22([blk], txt + "") : txt + "";
        };
      }
      module2.exports = $;
    });
    var require_action = __commonJS2((exports2, module2) => {
      "use strict";
      module2.exports = (key, isSelect) => {
        if (key.meta && key.name !== "escape")
          return;
        if (key.ctrl) {
          if (key.name === "a")
            return "first";
          if (key.name === "c")
            return "abort";
          if (key.name === "d")
            return "abort";
          if (key.name === "e")
            return "last";
          if (key.name === "g")
            return "reset";
        }
        if (isSelect) {
          if (key.name === "j")
            return "down";
          if (key.name === "k")
            return "up";
        }
        if (key.name === "return")
          return "submit";
        if (key.name === "enter")
          return "submit";
        if (key.name === "backspace")
          return "delete";
        if (key.name === "delete")
          return "deleteForward";
        if (key.name === "abort")
          return "abort";
        if (key.name === "escape")
          return "exit";
        if (key.name === "tab")
          return "next";
        if (key.name === "pagedown")
          return "nextPage";
        if (key.name === "pageup")
          return "prevPage";
        if (key.name === "home")
          return "home";
        if (key.name === "end")
          return "end";
        if (key.name === "up")
          return "up";
        if (key.name === "down")
          return "down";
        if (key.name === "right")
          return "right";
        if (key.name === "left")
          return "left";
        return false;
      };
    });
    var require_strip = __commonJS2((exports2, module2) => {
      "use strict";
      module2.exports = (str) => {
        const pattern = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[a-zA-Z\\d]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))"].join("|");
        const RGX = new RegExp(pattern, "g");
        return typeof str === "string" ? str.replace(RGX, "") : str;
      };
    });
    var require_src = __commonJS2((exports2, module2) => {
      "use strict";
      var ESC2 = "";
      var CSI = `${ESC2}[`;
      var beep = "\x07";
      var cursor = {
        to(x, y) {
          if (!y)
            return `${CSI}${x + 1}G`;
          return `${CSI}${y + 1};${x + 1}H`;
        },
        move(x, y) {
          let ret = "";
          if (x < 0)
            ret += `${CSI}${-x}D`;
          else if (x > 0)
            ret += `${CSI}${x}C`;
          if (y < 0)
            ret += `${CSI}${-y}A`;
          else if (y > 0)
            ret += `${CSI}${y}B`;
          return ret;
        },
        up: (count = 1) => `${CSI}${count}A`,
        down: (count = 1) => `${CSI}${count}B`,
        forward: (count = 1) => `${CSI}${count}C`,
        backward: (count = 1) => `${CSI}${count}D`,
        nextLine: (count = 1) => `${CSI}E`.repeat(count),
        prevLine: (count = 1) => `${CSI}F`.repeat(count),
        left: `${CSI}G`,
        hide: `${CSI}?25l`,
        show: `${CSI}?25h`,
        save: `${ESC2}7`,
        restore: `${ESC2}8`
      };
      var scroll = {
        up: (count = 1) => `${CSI}S`.repeat(count),
        down: (count = 1) => `${CSI}T`.repeat(count)
      };
      var erase = {
        screen: `${CSI}2J`,
        up: (count = 1) => `${CSI}1J`.repeat(count),
        down: (count = 1) => `${CSI}J`.repeat(count),
        line: `${CSI}2K`,
        lineEnd: `${CSI}K`,
        lineStart: `${CSI}1K`,
        lines(count) {
          let clear = "";
          for (let i = 0; i < count; i++)
            clear += this.line + (i < count - 1 ? cursor.up() : "");
          if (count)
            clear += cursor.left;
          return clear;
        }
      };
      module2.exports = { cursor, scroll, erase, beep };
    });
    var require_clear = __commonJS2((exports2, module2) => {
      "use strict";
      function _createForOfIteratorHelper(o, allowArrayLike) {
        var it;
        if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
          if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it)
              o = it;
            var i = 0;
            var F = function F2() {
            };
            return { s: F, n: function n() {
              if (i >= o.length)
                return { done: true };
              return { done: false, value: o[i++] };
            }, e: function e(_e) {
              throw _e;
            }, f: F };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var normalCompletion = true, didErr = false, err;
        return { s: function s() {
          it = o[Symbol.iterator]();
        }, n: function n() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        }, e: function e(_e2) {
          didErr = true;
          err = _e2;
        }, f: function f() {
          try {
            if (!normalCompletion && it.return != null)
              it.return();
          } finally {
            if (didErr)
              throw err;
          }
        } };
      }
      function _unsupportedIterableToArray(o, minLen) {
        if (!o)
          return;
        if (typeof o === "string")
          return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor)
          n = o.constructor.name;
        if (n === "Map" || n === "Set")
          return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _arrayLikeToArray(o, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++)
          arr2[i] = arr[i];
        return arr2;
      }
      var strip = require_strip();
      var _require = require_src();
      var erase = _require.erase;
      var cursor = _require.cursor;
      var width = (str) => [...strip(str)].length;
      module2.exports = function(prompt, perLine) {
        if (!perLine)
          return erase.line + cursor.to(0);
        let rows = 0;
        const lines = prompt.split(/\r?\n/);
        var _iterator = _createForOfIteratorHelper(lines), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            let line = _step.value;
            rows += 1 + Math.floor(Math.max(width(line) - 1, 0) / perLine);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return erase.lines(rows);
      };
    });
    var require_figures = __commonJS2((exports2, module2) => {
      "use strict";
      var main = {
        arrowUp: "\u2191",
        arrowDown: "\u2193",
        arrowLeft: "\u2190",
        arrowRight: "\u2192",
        radioOn: "\u25C9",
        radioOff: "\u25EF",
        tick: "\u2714",
        cross: "\u2716",
        ellipsis: "\u2026",
        pointerSmall: "\u203A",
        line: "\u2500",
        pointer: "\u276F"
      };
      var win = {
        arrowUp: main.arrowUp,
        arrowDown: main.arrowDown,
        arrowLeft: main.arrowLeft,
        arrowRight: main.arrowRight,
        radioOn: "(*)",
        radioOff: "( )",
        tick: "\u221A",
        cross: "\xD7",
        ellipsis: "...",
        pointerSmall: "\xBB",
        line: "\u2500",
        pointer: ">"
      };
      var figures = process.platform === "win32" ? win : main;
      module2.exports = figures;
    });
    var require_style = __commonJS2((exports2, module2) => {
      "use strict";
      var c = require_kleur();
      var figures = require_figures();
      var styles = Object.freeze({
        password: {
          scale: 1,
          render: (input) => "*".repeat(input.length)
        },
        emoji: {
          scale: 2,
          render: (input) => "\u{1F603}".repeat(input.length)
        },
        invisible: {
          scale: 0,
          render: (input) => ""
        },
        default: {
          scale: 1,
          render: (input) => `${input}`
        }
      });
      var render = (type) => styles[type] || styles.default;
      var symbols = Object.freeze({
        aborted: c.red(figures.cross),
        done: c.green(figures.tick),
        exited: c.yellow(figures.cross),
        default: c.cyan("?")
      });
      var symbol = (done, aborted, exited) => aborted ? symbols.aborted : exited ? symbols.exited : done ? symbols.done : symbols.default;
      var delimiter = (completing) => c.gray(completing ? figures.ellipsis : figures.pointerSmall);
      var item = (expandable, expanded) => c.gray(expandable ? expanded ? figures.pointerSmall : "+" : figures.line);
      module2.exports = {
        styles,
        render,
        symbols,
        symbol,
        delimiter,
        item
      };
    });
    var require_lines = __commonJS2((exports2, module2) => {
      "use strict";
      var strip = require_strip();
      module2.exports = function(msg, perLine) {
        let lines = String(strip(msg) || "").split(/\r?\n/);
        if (!perLine)
          return lines.length;
        return lines.map((l) => Math.ceil(l.length / perLine)).reduce((a, b) => a + b);
      };
    });
    var require_wrap = __commonJS2((exports2, module2) => {
      "use strict";
      module2.exports = (msg, opts = {}) => {
        const tab = Number.isSafeInteger(parseInt(opts.margin)) ? new Array(parseInt(opts.margin)).fill(" ").join("") : opts.margin || "";
        const width = opts.width;
        return (msg || "").split(/\r?\n/g).map((line) => line.split(/\s+/g).reduce((arr, w) => {
          if (w.length + tab.length >= width || arr[arr.length - 1].length + w.length + 1 < width)
            arr[arr.length - 1] += ` ${w}`;
          else
            arr.push(`${tab}${w}`);
          return arr;
        }, [tab]).join("\n")).join("\n");
      };
    });
    var require_entriesToDisplay = __commonJS2((exports2, module2) => {
      "use strict";
      module2.exports = (cursor, total, maxVisible) => {
        maxVisible = maxVisible || total;
        let startIndex = Math.min(total - maxVisible, cursor - Math.floor(maxVisible / 2));
        if (startIndex < 0)
          startIndex = 0;
        let endIndex = Math.min(startIndex + maxVisible, total);
        return {
          startIndex,
          endIndex
        };
      };
    });
    var require_util = __commonJS2((exports2, module2) => {
      "use strict";
      module2.exports = {
        action: require_action(),
        clear: require_clear(),
        style: require_style(),
        strip: require_strip(),
        figures: require_figures(),
        lines: require_lines(),
        wrap: require_wrap(),
        entriesToDisplay: require_entriesToDisplay()
      };
    });
    var require_prompt = __commonJS2((exports2, module2) => {
      "use strict";
      var readline = _chunkKRCSYS75js.__require.call(void 0, "readline");
      var _require = require_util();
      var action = _require.action;
      var EventEmitter = _chunkKRCSYS75js.__require.call(void 0, "events");
      var _require2 = require_src();
      var beep = _require2.beep;
      var cursor = _require2.cursor;
      var color = require_kleur();
      var Prompt = class extends EventEmitter {
        constructor(opts = {}) {
          super();
          this.firstRender = true;
          this.in = opts.stdin || process.stdin;
          this.out = opts.stdout || process.stdout;
          this.onRender = (opts.onRender || (() => void 0)).bind(this);
          const rl = readline.createInterface({
            input: this.in,
            escapeCodeTimeout: 50
          });
          readline.emitKeypressEvents(this.in, rl);
          if (this.in.isTTY)
            this.in.setRawMode(true);
          const isSelect = ["SelectPrompt", "MultiselectPrompt"].indexOf(this.constructor.name) > -1;
          const keypress = (str, key) => {
            let a = action(key, isSelect);
            if (a === false) {
              this._ && this._(str, key);
            } else if (typeof this[a] === "function") {
              this[a](key);
            } else {
              this.bell();
            }
          };
          this.close = () => {
            this.out.write(cursor.show);
            this.in.removeListener("keypress", keypress);
            if (this.in.isTTY)
              this.in.setRawMode(false);
            rl.close();
            this.emit(this.aborted ? "abort" : this.exited ? "exit" : "submit", this.value);
            this.closed = true;
          };
          this.in.on("keypress", keypress);
        }
        fire() {
          this.emit("state", {
            value: this.value,
            aborted: !!this.aborted,
            exited: !!this.exited
          });
        }
        bell() {
          this.out.write(beep);
        }
        render() {
          this.onRender(color);
          if (this.firstRender)
            this.firstRender = false;
        }
      };
      module2.exports = Prompt;
    });
    var require_text = __commonJS2((exports2, module2) => {
      "use strict";
      function asyncGeneratorStep(gen, resolve2, reject, _next, _throw, key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }
        if (info.done) {
          resolve2(value);
        } else {
          Promise.resolve(value).then(_next, _throw);
        }
      }
      function _asyncToGenerator(fn) {
        return function() {
          var self = this, args = arguments;
          return new Promise(function(resolve2, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
              asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
              asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "throw", err);
            }
            _next(void 0);
          });
        };
      }
      var color = require_kleur();
      var Prompt = require_prompt();
      var _require = require_src();
      var erase = _require.erase;
      var cursor = _require.cursor;
      var _require2 = require_util();
      var style = _require2.style;
      var clear = _require2.clear;
      var lines = _require2.lines;
      var figures = _require2.figures;
      var TextPrompt = class extends Prompt {
        constructor(opts = {}) {
          super(opts);
          this.transform = style.render(opts.style);
          this.scale = this.transform.scale;
          this.msg = opts.message;
          this.initial = opts.initial || ``;
          this.validator = opts.validate || (() => true);
          this.value = ``;
          this.errorMsg = opts.error || `Please Enter A Valid Value`;
          this.cursor = Number(!!this.initial);
          this.cursorOffset = 0;
          this.clear = clear(``, this.out.columns);
          this.render();
        }
        set value(v) {
          if (!v && this.initial) {
            this.placeholder = true;
            this.rendered = color.gray(this.transform.render(this.initial));
          } else {
            this.placeholder = false;
            this.rendered = this.transform.render(v);
          }
          this._value = v;
          this.fire();
        }
        get value() {
          return this._value;
        }
        reset() {
          this.value = ``;
          this.cursor = Number(!!this.initial);
          this.cursorOffset = 0;
          this.fire();
          this.render();
        }
        exit() {
          this.abort();
        }
        abort() {
          this.value = this.value || this.initial;
          this.done = this.aborted = true;
          this.error = false;
          this.red = false;
          this.fire();
          this.render();
          this.out.write("\n");
          this.close();
        }
        validate() {
          var _this = this;
          return _asyncToGenerator(function* () {
            let valid = yield _this.validator(_this.value);
            if (typeof valid === `string`) {
              _this.errorMsg = valid;
              valid = false;
            }
            _this.error = !valid;
          })();
        }
        submit() {
          var _this2 = this;
          return _asyncToGenerator(function* () {
            _this2.value = _this2.value || _this2.initial;
            _this2.cursorOffset = 0;
            _this2.cursor = _this2.rendered.length;
            yield _this2.validate();
            if (_this2.error) {
              _this2.red = true;
              _this2.fire();
              _this2.render();
              return;
            }
            _this2.done = true;
            _this2.aborted = false;
            _this2.fire();
            _this2.render();
            _this2.out.write("\n");
            _this2.close();
          })();
        }
        next() {
          if (!this.placeholder)
            return this.bell();
          this.value = this.initial;
          this.cursor = this.rendered.length;
          this.fire();
          this.render();
        }
        moveCursor(n) {
          if (this.placeholder)
            return;
          this.cursor = this.cursor + n;
          this.cursorOffset += n;
        }
        _(c, key) {
          let s1 = this.value.slice(0, this.cursor);
          let s2 = this.value.slice(this.cursor);
          this.value = `${s1}${c}${s2}`;
          this.red = false;
          this.cursor = this.placeholder ? 0 : s1.length + 1;
          this.render();
        }
        delete() {
          if (this.isCursorAtStart())
            return this.bell();
          let s1 = this.value.slice(0, this.cursor - 1);
          let s2 = this.value.slice(this.cursor);
          this.value = `${s1}${s2}`;
          this.red = false;
          if (this.isCursorAtStart()) {
            this.cursorOffset = 0;
          } else {
            this.cursorOffset++;
            this.moveCursor(-1);
          }
          this.render();
        }
        deleteForward() {
          if (this.cursor * this.scale >= this.rendered.length || this.placeholder)
            return this.bell();
          let s1 = this.value.slice(0, this.cursor);
          let s2 = this.value.slice(this.cursor + 1);
          this.value = `${s1}${s2}`;
          this.red = false;
          if (this.isCursorAtEnd()) {
            this.cursorOffset = 0;
          } else {
            this.cursorOffset++;
          }
          this.render();
        }
        first() {
          this.cursor = 0;
          this.render();
        }
        last() {
          this.cursor = this.value.length;
          this.render();
        }
        left() {
          if (this.cursor <= 0 || this.placeholder)
            return this.bell();
          this.moveCursor(-1);
          this.render();
        }
        right() {
          if (this.cursor * this.scale >= this.rendered.length || this.placeholder)
            return this.bell();
          this.moveCursor(1);
          this.render();
        }
        isCursorAtStart() {
          return this.cursor === 0 || this.placeholder && this.cursor === 1;
        }
        isCursorAtEnd() {
          return this.cursor === this.rendered.length || this.placeholder && this.cursor === this.rendered.length + 1;
        }
        render() {
          if (this.closed)
            return;
          if (!this.firstRender) {
            if (this.outputError)
              this.out.write(cursor.down(lines(this.outputError, this.out.columns) - 1) + clear(this.outputError, this.out.columns));
            this.out.write(clear(this.outputText, this.out.columns));
          }
          super.render();
          this.outputError = "";
          this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(this.done), this.red ? color.red(this.rendered) : this.rendered].join(` `);
          if (this.error) {
            this.outputError += this.errorMsg.split(`
`).reduce((a, l, i) => a + `
${i ? " " : figures.pointerSmall} ${color.red().italic(l)}`, ``);
          }
          this.out.write(erase.line + cursor.to(0) + this.outputText + cursor.save + this.outputError + cursor.restore + cursor.move(this.cursorOffset, 0));
        }
      };
      module2.exports = TextPrompt;
    });
    var require_select = __commonJS2((exports2, module2) => {
      "use strict";
      var color = require_kleur();
      var Prompt = require_prompt();
      var _require = require_util();
      var style = _require.style;
      var clear = _require.clear;
      var figures = _require.figures;
      var wrap = _require.wrap;
      var entriesToDisplay = _require.entriesToDisplay;
      var _require2 = require_src();
      var cursor = _require2.cursor;
      var SelectPrompt = class extends Prompt {
        constructor(opts = {}) {
          super(opts);
          this.msg = opts.message;
          this.hint = opts.hint || "- Use arrow-keys. Return to submit.";
          this.warn = opts.warn || "- This option is disabled";
          this.cursor = opts.initial || 0;
          this.choices = opts.choices.map((ch, idx) => {
            if (typeof ch === "string")
              ch = {
                title: ch,
                value: idx
              };
            return {
              title: ch && (ch.title || ch.value || ch),
              value: ch && (ch.value === void 0 ? idx : ch.value),
              description: ch && ch.description,
              selected: ch && ch.selected,
              disabled: ch && ch.disabled
            };
          });
          this.optionsPerPage = opts.optionsPerPage || 10;
          this.value = (this.choices[this.cursor] || {}).value;
          this.clear = clear("", this.out.columns);
          this.render();
        }
        moveCursor(n) {
          this.cursor = n;
          this.value = this.choices[n].value;
          this.fire();
        }
        reset() {
          this.moveCursor(0);
          this.fire();
          this.render();
        }
        exit() {
          this.abort();
        }
        abort() {
          this.done = this.aborted = true;
          this.fire();
          this.render();
          this.out.write("\n");
          this.close();
        }
        submit() {
          if (!this.selection.disabled) {
            this.done = true;
            this.aborted = false;
            this.fire();
            this.render();
            this.out.write("\n");
            this.close();
          } else
            this.bell();
        }
        first() {
          this.moveCursor(0);
          this.render();
        }
        last() {
          this.moveCursor(this.choices.length - 1);
          this.render();
        }
        up() {
          if (this.cursor === 0) {
            this.moveCursor(this.choices.length - 1);
          } else {
            this.moveCursor(this.cursor - 1);
          }
          this.render();
        }
        down() {
          if (this.cursor === this.choices.length - 1) {
            this.moveCursor(0);
          } else {
            this.moveCursor(this.cursor + 1);
          }
          this.render();
        }
        next() {
          this.moveCursor((this.cursor + 1) % this.choices.length);
          this.render();
        }
        _(c, key) {
          if (c === " ")
            return this.submit();
        }
        get selection() {
          return this.choices[this.cursor];
        }
        render() {
          if (this.closed)
            return;
          if (this.firstRender)
            this.out.write(cursor.hide);
          else
            this.out.write(clear(this.outputText, this.out.columns));
          super.render();
          let _entriesToDisplay = entriesToDisplay(this.cursor, this.choices.length, this.optionsPerPage), startIndex = _entriesToDisplay.startIndex, endIndex = _entriesToDisplay.endIndex;
          this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(false), this.done ? this.selection.title : this.selection.disabled ? color.yellow(this.warn) : color.gray(this.hint)].join(" ");
          if (!this.done) {
            this.outputText += "\n";
            for (let i = startIndex; i < endIndex; i++) {
              let title, prefix, desc = "", v = this.choices[i];
              if (i === startIndex && startIndex > 0) {
                prefix = figures.arrowUp;
              } else if (i === endIndex - 1 && endIndex < this.choices.length) {
                prefix = figures.arrowDown;
              } else {
                prefix = " ";
              }
              if (v.disabled) {
                title = this.cursor === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
                prefix = (this.cursor === i ? color.bold().gray(figures.pointer) + " " : "  ") + prefix;
              } else {
                title = this.cursor === i ? color.cyan().underline(v.title) : v.title;
                prefix = (this.cursor === i ? color.cyan(figures.pointer) + " " : "  ") + prefix;
                if (v.description && this.cursor === i) {
                  desc = ` - ${v.description}`;
                  if (prefix.length + title.length + desc.length >= this.out.columns || v.description.split(/\r?\n/).length > 1) {
                    desc = "\n" + wrap(v.description, {
                      margin: 3,
                      width: this.out.columns
                    });
                  }
                }
              }
              this.outputText += `${prefix} ${title}${color.gray(desc)}
`;
            }
          }
          this.out.write(this.outputText);
        }
      };
      module2.exports = SelectPrompt;
    });
    var require_toggle = __commonJS2((exports2, module2) => {
      "use strict";
      var color = require_kleur();
      var Prompt = require_prompt();
      var _require = require_util();
      var style = _require.style;
      var clear = _require.clear;
      var _require2 = require_src();
      var cursor = _require2.cursor;
      var erase = _require2.erase;
      var TogglePrompt = class extends Prompt {
        constructor(opts = {}) {
          super(opts);
          this.msg = opts.message;
          this.value = !!opts.initial;
          this.active = opts.active || "on";
          this.inactive = opts.inactive || "off";
          this.initialValue = this.value;
          this.render();
        }
        reset() {
          this.value = this.initialValue;
          this.fire();
          this.render();
        }
        exit() {
          this.abort();
        }
        abort() {
          this.done = this.aborted = true;
          this.fire();
          this.render();
          this.out.write("\n");
          this.close();
        }
        submit() {
          this.done = true;
          this.aborted = false;
          this.fire();
          this.render();
          this.out.write("\n");
          this.close();
        }
        deactivate() {
          if (this.value === false)
            return this.bell();
          this.value = false;
          this.render();
        }
        activate() {
          if (this.value === true)
            return this.bell();
          this.value = true;
          this.render();
        }
        delete() {
          this.deactivate();
        }
        left() {
          this.deactivate();
        }
        right() {
          this.activate();
        }
        down() {
          this.deactivate();
        }
        up() {
          this.activate();
        }
        next() {
          this.value = !this.value;
          this.fire();
          this.render();
        }
        _(c, key) {
          if (c === " ") {
            this.value = !this.value;
          } else if (c === "1") {
            this.value = true;
          } else if (c === "0") {
            this.value = false;
          } else
            return this.bell();
          this.render();
        }
        render() {
          if (this.closed)
            return;
          if (this.firstRender)
            this.out.write(cursor.hide);
          else
            this.out.write(clear(this.outputText, this.out.columns));
          super.render();
          this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(this.done), this.value ? this.inactive : color.cyan().underline(this.inactive), color.gray("/"), this.value ? color.cyan().underline(this.active) : this.active].join(" ");
          this.out.write(erase.line + cursor.to(0) + this.outputText);
        }
      };
      module2.exports = TogglePrompt;
    });
    var require_datepart = __commonJS2((exports2, module2) => {
      "use strict";
      var DatePart = class {
        constructor({
          token,
          date,
          parts,
          locales
        }) {
          this.token = token;
          this.date = date || new Date();
          this.parts = parts || [this];
          this.locales = locales || {};
        }
        up() {
        }
        down() {
        }
        next() {
          const currentIdx = this.parts.indexOf(this);
          return this.parts.find((part, idx) => idx > currentIdx && part instanceof DatePart);
        }
        setTo(val) {
        }
        prev() {
          let parts = [].concat(this.parts).reverse();
          const currentIdx = parts.indexOf(this);
          return parts.find((part, idx) => idx > currentIdx && part instanceof DatePart);
        }
        toString() {
          return String(this.date);
        }
      };
      module2.exports = DatePart;
    });
    var require_meridiem = __commonJS2((exports2, module2) => {
      "use strict";
      var DatePart = require_datepart();
      var Meridiem = class extends DatePart {
        constructor(opts = {}) {
          super(opts);
        }
        up() {
          this.date.setHours((this.date.getHours() + 12) % 24);
        }
        down() {
          this.up();
        }
        toString() {
          let meridiem = this.date.getHours() > 12 ? "pm" : "am";
          return /\A/.test(this.token) ? meridiem.toUpperCase() : meridiem;
        }
      };
      module2.exports = Meridiem;
    });
    var require_day = __commonJS2((exports2, module2) => {
      "use strict";
      var DatePart = require_datepart();
      var pos = (n) => {
        n = n % 10;
        return n === 1 ? "st" : n === 2 ? "nd" : n === 3 ? "rd" : "th";
      };
      var Day = class extends DatePart {
        constructor(opts = {}) {
          super(opts);
        }
        up() {
          this.date.setDate(this.date.getDate() + 1);
        }
        down() {
          this.date.setDate(this.date.getDate() - 1);
        }
        setTo(val) {
          this.date.setDate(parseInt(val.substr(-2)));
        }
        toString() {
          let date = this.date.getDate();
          let day = this.date.getDay();
          return this.token === "DD" ? String(date).padStart(2, "0") : this.token === "Do" ? date + pos(date) : this.token === "d" ? day + 1 : this.token === "ddd" ? this.locales.weekdaysShort[day] : this.token === "dddd" ? this.locales.weekdays[day] : date;
        }
      };
      module2.exports = Day;
    });
    var require_hours = __commonJS2((exports2, module2) => {
      "use strict";
      var DatePart = require_datepart();
      var Hours = class extends DatePart {
        constructor(opts = {}) {
          super(opts);
        }
        up() {
          this.date.setHours(this.date.getHours() + 1);
        }
        down() {
          this.date.setHours(this.date.getHours() - 1);
        }
        setTo(val) {
          this.date.setHours(parseInt(val.substr(-2)));
        }
        toString() {
          let hours = this.date.getHours();
          if (/h/.test(this.token))
            hours = hours % 12 || 12;
          return this.token.length > 1 ? String(hours).padStart(2, "0") : hours;
        }
      };
      module2.exports = Hours;
    });
    var require_milliseconds = __commonJS2((exports2, module2) => {
      "use strict";
      var DatePart = require_datepart();
      var Milliseconds = class extends DatePart {
        constructor(opts = {}) {
          super(opts);
        }
        up() {
          this.date.setMilliseconds(this.date.getMilliseconds() + 1);
        }
        down() {
          this.date.setMilliseconds(this.date.getMilliseconds() - 1);
        }
        setTo(val) {
          this.date.setMilliseconds(parseInt(val.substr(-this.token.length)));
        }
        toString() {
          return String(this.date.getMilliseconds()).padStart(4, "0").substr(0, this.token.length);
        }
      };
      module2.exports = Milliseconds;
    });
    var require_minutes = __commonJS2((exports2, module2) => {
      "use strict";
      var DatePart = require_datepart();
      var Minutes = class extends DatePart {
        constructor(opts = {}) {
          super(opts);
        }
        up() {
          this.date.setMinutes(this.date.getMinutes() + 1);
        }
        down() {
          this.date.setMinutes(this.date.getMinutes() - 1);
        }
        setTo(val) {
          this.date.setMinutes(parseInt(val.substr(-2)));
        }
        toString() {
          let m = this.date.getMinutes();
          return this.token.length > 1 ? String(m).padStart(2, "0") : m;
        }
      };
      module2.exports = Minutes;
    });
    var require_month = __commonJS2((exports2, module2) => {
      "use strict";
      var DatePart = require_datepart();
      var Month = class extends DatePart {
        constructor(opts = {}) {
          super(opts);
        }
        up() {
          this.date.setMonth(this.date.getMonth() + 1);
        }
        down() {
          this.date.setMonth(this.date.getMonth() - 1);
        }
        setTo(val) {
          val = parseInt(val.substr(-2)) - 1;
          this.date.setMonth(val < 0 ? 0 : val);
        }
        toString() {
          let month = this.date.getMonth();
          let tl = this.token.length;
          return tl === 2 ? String(month + 1).padStart(2, "0") : tl === 3 ? this.locales.monthsShort[month] : tl === 4 ? this.locales.months[month] : String(month + 1);
        }
      };
      module2.exports = Month;
    });
    var require_seconds = __commonJS2((exports2, module2) => {
      "use strict";
      var DatePart = require_datepart();
      var Seconds = class extends DatePart {
        constructor(opts = {}) {
          super(opts);
        }
        up() {
          this.date.setSeconds(this.date.getSeconds() + 1);
        }
        down() {
          this.date.setSeconds(this.date.getSeconds() - 1);
        }
        setTo(val) {
          this.date.setSeconds(parseInt(val.substr(-2)));
        }
        toString() {
          let s = this.date.getSeconds();
          return this.token.length > 1 ? String(s).padStart(2, "0") : s;
        }
      };
      module2.exports = Seconds;
    });
    var require_year = __commonJS2((exports2, module2) => {
      "use strict";
      var DatePart = require_datepart();
      var Year = class extends DatePart {
        constructor(opts = {}) {
          super(opts);
        }
        up() {
          this.date.setFullYear(this.date.getFullYear() + 1);
        }
        down() {
          this.date.setFullYear(this.date.getFullYear() - 1);
        }
        setTo(val) {
          this.date.setFullYear(val.substr(-4));
        }
        toString() {
          let year = String(this.date.getFullYear()).padStart(4, "0");
          return this.token.length === 2 ? year.substr(-2) : year;
        }
      };
      module2.exports = Year;
    });
    var require_dateparts = __commonJS2((exports2, module2) => {
      "use strict";
      module2.exports = {
        DatePart: require_datepart(),
        Meridiem: require_meridiem(),
        Day: require_day(),
        Hours: require_hours(),
        Milliseconds: require_milliseconds(),
        Minutes: require_minutes(),
        Month: require_month(),
        Seconds: require_seconds(),
        Year: require_year()
      };
    });
    var require_date = __commonJS2((exports2, module2) => {
      "use strict";
      function asyncGeneratorStep(gen, resolve2, reject, _next, _throw, key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }
        if (info.done) {
          resolve2(value);
        } else {
          Promise.resolve(value).then(_next, _throw);
        }
      }
      function _asyncToGenerator(fn) {
        return function() {
          var self = this, args = arguments;
          return new Promise(function(resolve2, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
              asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
              asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "throw", err);
            }
            _next(void 0);
          });
        };
      }
      var color = require_kleur();
      var Prompt = require_prompt();
      var _require = require_util();
      var style = _require.style;
      var clear = _require.clear;
      var figures = _require.figures;
      var _require2 = require_src();
      var erase = _require2.erase;
      var cursor = _require2.cursor;
      var _require3 = require_dateparts();
      var DatePart = _require3.DatePart;
      var Meridiem = _require3.Meridiem;
      var Day = _require3.Day;
      var Hours = _require3.Hours;
      var Milliseconds = _require3.Milliseconds;
      var Minutes = _require3.Minutes;
      var Month = _require3.Month;
      var Seconds = _require3.Seconds;
      var Year = _require3.Year;
      var regex = /\\(.)|"((?:\\["\\]|[^"])+)"|(D[Do]?|d{3,4}|d)|(M{1,4})|(YY(?:YY)?)|([aA])|([Hh]{1,2})|(m{1,2})|(s{1,2})|(S{1,4})|./g;
      var regexGroups = {
        1: ({
          token
        }) => token.replace(/\\(.)/g, "$1"),
        2: (opts) => new Day(opts),
        3: (opts) => new Month(opts),
        4: (opts) => new Year(opts),
        5: (opts) => new Meridiem(opts),
        6: (opts) => new Hours(opts),
        7: (opts) => new Minutes(opts),
        8: (opts) => new Seconds(opts),
        9: (opts) => new Milliseconds(opts)
      };
      var dfltLocales = {
        months: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
        monthsShort: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
        weekdays: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
        weekdaysShort: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(",")
      };
      var DatePrompt = class extends Prompt {
        constructor(opts = {}) {
          super(opts);
          this.msg = opts.message;
          this.cursor = 0;
          this.typed = "";
          this.locales = Object.assign(dfltLocales, opts.locales);
          this._date = opts.initial || new Date();
          this.errorMsg = opts.error || "Please Enter A Valid Value";
          this.validator = opts.validate || (() => true);
          this.mask = opts.mask || "YYYY-MM-DD HH:mm:ss";
          this.clear = clear("", this.out.columns);
          this.render();
        }
        get value() {
          return this.date;
        }
        get date() {
          return this._date;
        }
        set date(date) {
          if (date)
            this._date.setTime(date.getTime());
        }
        set mask(mask) {
          let result;
          this.parts = [];
          while (result = regex.exec(mask)) {
            let match = result.shift();
            let idx = result.findIndex((gr) => gr != null);
            this.parts.push(idx in regexGroups ? regexGroups[idx]({
              token: result[idx] || match,
              date: this.date,
              parts: this.parts,
              locales: this.locales
            }) : result[idx] || match);
          }
          let parts = this.parts.reduce((arr, i) => {
            if (typeof i === "string" && typeof arr[arr.length - 1] === "string")
              arr[arr.length - 1] += i;
            else
              arr.push(i);
            return arr;
          }, []);
          this.parts.splice(0);
          this.parts.push(...parts);
          this.reset();
        }
        moveCursor(n) {
          this.typed = "";
          this.cursor = n;
          this.fire();
        }
        reset() {
          this.moveCursor(this.parts.findIndex((p) => p instanceof DatePart));
          this.fire();
          this.render();
        }
        exit() {
          this.abort();
        }
        abort() {
          this.done = this.aborted = true;
          this.error = false;
          this.fire();
          this.render();
          this.out.write("\n");
          this.close();
        }
        validate() {
          var _this = this;
          return _asyncToGenerator(function* () {
            let valid = yield _this.validator(_this.value);
            if (typeof valid === "string") {
              _this.errorMsg = valid;
              valid = false;
            }
            _this.error = !valid;
          })();
        }
        submit() {
          var _this2 = this;
          return _asyncToGenerator(function* () {
            yield _this2.validate();
            if (_this2.error) {
              _this2.color = "red";
              _this2.fire();
              _this2.render();
              return;
            }
            _this2.done = true;
            _this2.aborted = false;
            _this2.fire();
            _this2.render();
            _this2.out.write("\n");
            _this2.close();
          })();
        }
        up() {
          this.typed = "";
          this.parts[this.cursor].up();
          this.render();
        }
        down() {
          this.typed = "";
          this.parts[this.cursor].down();
          this.render();
        }
        left() {
          let prev = this.parts[this.cursor].prev();
          if (prev == null)
            return this.bell();
          this.moveCursor(this.parts.indexOf(prev));
          this.render();
        }
        right() {
          let next = this.parts[this.cursor].next();
          if (next == null)
            return this.bell();
          this.moveCursor(this.parts.indexOf(next));
          this.render();
        }
        next() {
          let next = this.parts[this.cursor].next();
          this.moveCursor(next ? this.parts.indexOf(next) : this.parts.findIndex((part) => part instanceof DatePart));
          this.render();
        }
        _(c) {
          if (/\d/.test(c)) {
            this.typed += c;
            this.parts[this.cursor].setTo(this.typed);
            this.render();
          }
        }
        render() {
          if (this.closed)
            return;
          if (this.firstRender)
            this.out.write(cursor.hide);
          else
            this.out.write(clear(this.outputText, this.out.columns));
          super.render();
          this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(false), this.parts.reduce((arr, p, idx) => arr.concat(idx === this.cursor && !this.done ? color.cyan().underline(p.toString()) : p), []).join("")].join(" ");
          if (this.error) {
            this.outputText += this.errorMsg.split("\n").reduce((a, l, i) => a + `
${i ? ` ` : figures.pointerSmall} ${color.red().italic(l)}`, ``);
          }
          this.out.write(erase.line + cursor.to(0) + this.outputText);
        }
      };
      module2.exports = DatePrompt;
    });
    var require_number = __commonJS2((exports2, module2) => {
      "use strict";
      function asyncGeneratorStep(gen, resolve2, reject, _next, _throw, key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }
        if (info.done) {
          resolve2(value);
        } else {
          Promise.resolve(value).then(_next, _throw);
        }
      }
      function _asyncToGenerator(fn) {
        return function() {
          var self = this, args = arguments;
          return new Promise(function(resolve2, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
              asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
              asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "throw", err);
            }
            _next(void 0);
          });
        };
      }
      var color = require_kleur();
      var Prompt = require_prompt();
      var _require = require_src();
      var cursor = _require.cursor;
      var erase = _require.erase;
      var _require2 = require_util();
      var style = _require2.style;
      var figures = _require2.figures;
      var clear = _require2.clear;
      var lines = _require2.lines;
      var isNumber = /[0-9]/;
      var isDef = (any) => any !== void 0;
      var round = (number, precision) => {
        let factor = Math.pow(10, precision);
        return Math.round(number * factor) / factor;
      };
      var NumberPrompt = class extends Prompt {
        constructor(opts = {}) {
          super(opts);
          this.transform = style.render(opts.style);
          this.msg = opts.message;
          this.initial = isDef(opts.initial) ? opts.initial : "";
          this.float = !!opts.float;
          this.round = opts.round || 2;
          this.inc = opts.increment || 1;
          this.min = isDef(opts.min) ? opts.min : -Infinity;
          this.max = isDef(opts.max) ? opts.max : Infinity;
          this.errorMsg = opts.error || `Please Enter A Valid Value`;
          this.validator = opts.validate || (() => true);
          this.color = `cyan`;
          this.value = ``;
          this.typed = ``;
          this.lastHit = 0;
          this.render();
        }
        set value(v) {
          if (!v && v !== 0) {
            this.placeholder = true;
            this.rendered = color.gray(this.transform.render(`${this.initial}`));
            this._value = ``;
          } else {
            this.placeholder = false;
            this.rendered = this.transform.render(`${round(v, this.round)}`);
            this._value = round(v, this.round);
          }
          this.fire();
        }
        get value() {
          return this._value;
        }
        parse(x) {
          return this.float ? parseFloat(x) : parseInt(x);
        }
        valid(c) {
          return c === `-` || c === `.` && this.float || isNumber.test(c);
        }
        reset() {
          this.typed = ``;
          this.value = ``;
          this.fire();
          this.render();
        }
        exit() {
          this.abort();
        }
        abort() {
          let x = this.value;
          this.value = x !== `` ? x : this.initial;
          this.done = this.aborted = true;
          this.error = false;
          this.fire();
          this.render();
          this.out.write(`
`);
          this.close();
        }
        validate() {
          var _this = this;
          return _asyncToGenerator(function* () {
            let valid = yield _this.validator(_this.value);
            if (typeof valid === `string`) {
              _this.errorMsg = valid;
              valid = false;
            }
            _this.error = !valid;
          })();
        }
        submit() {
          var _this2 = this;
          return _asyncToGenerator(function* () {
            yield _this2.validate();
            if (_this2.error) {
              _this2.color = `red`;
              _this2.fire();
              _this2.render();
              return;
            }
            let x = _this2.value;
            _this2.value = x !== `` ? x : _this2.initial;
            _this2.done = true;
            _this2.aborted = false;
            _this2.error = false;
            _this2.fire();
            _this2.render();
            _this2.out.write(`
`);
            _this2.close();
          })();
        }
        up() {
          this.typed = ``;
          if (this.value === "") {
            this.value = this.min - this.inc;
          }
          if (this.value >= this.max)
            return this.bell();
          this.value += this.inc;
          this.color = `cyan`;
          this.fire();
          this.render();
        }
        down() {
          this.typed = ``;
          if (this.value === "") {
            this.value = this.min + this.inc;
          }
          if (this.value <= this.min)
            return this.bell();
          this.value -= this.inc;
          this.color = `cyan`;
          this.fire();
          this.render();
        }
        delete() {
          let val = this.value.toString();
          if (val.length === 0)
            return this.bell();
          this.value = this.parse(val = val.slice(0, -1)) || ``;
          if (this.value !== "" && this.value < this.min) {
            this.value = this.min;
          }
          this.color = `cyan`;
          this.fire();
          this.render();
        }
        next() {
          this.value = this.initial;
          this.fire();
          this.render();
        }
        _(c, key) {
          if (!this.valid(c))
            return this.bell();
          const now = Date.now();
          if (now - this.lastHit > 1e3)
            this.typed = ``;
          this.typed += c;
          this.lastHit = now;
          this.color = `cyan`;
          if (c === `.`)
            return this.fire();
          this.value = Math.min(this.parse(this.typed), this.max);
          if (this.value > this.max)
            this.value = this.max;
          if (this.value < this.min)
            this.value = this.min;
          this.fire();
          this.render();
        }
        render() {
          if (this.closed)
            return;
          if (!this.firstRender) {
            if (this.outputError)
              this.out.write(cursor.down(lines(this.outputError, this.out.columns) - 1) + clear(this.outputError, this.out.columns));
            this.out.write(clear(this.outputText, this.out.columns));
          }
          super.render();
          this.outputError = "";
          this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(this.done), !this.done || !this.done && !this.placeholder ? color[this.color]().underline(this.rendered) : this.rendered].join(` `);
          if (this.error) {
            this.outputError += this.errorMsg.split(`
`).reduce((a, l, i) => a + `
${i ? ` ` : figures.pointerSmall} ${color.red().italic(l)}`, ``);
          }
          this.out.write(erase.line + cursor.to(0) + this.outputText + cursor.save + this.outputError + cursor.restore);
        }
      };
      module2.exports = NumberPrompt;
    });
    var require_multiselect = __commonJS2((exports2, module2) => {
      "use strict";
      var color = require_kleur();
      var _require = require_src();
      var cursor = _require.cursor;
      var Prompt = require_prompt();
      var _require2 = require_util();
      var clear = _require2.clear;
      var figures = _require2.figures;
      var style = _require2.style;
      var wrap = _require2.wrap;
      var entriesToDisplay = _require2.entriesToDisplay;
      var MultiselectPrompt = class extends Prompt {
        constructor(opts = {}) {
          super(opts);
          this.msg = opts.message;
          this.cursor = opts.cursor || 0;
          this.scrollIndex = opts.cursor || 0;
          this.hint = opts.hint || "";
          this.warn = opts.warn || "- This option is disabled -";
          this.minSelected = opts.min;
          this.showMinError = false;
          this.maxChoices = opts.max;
          this.instructions = opts.instructions;
          this.optionsPerPage = opts.optionsPerPage || 10;
          this.value = opts.choices.map((ch, idx) => {
            if (typeof ch === "string")
              ch = {
                title: ch,
                value: idx
              };
            return {
              title: ch && (ch.title || ch.value || ch),
              description: ch && ch.description,
              value: ch && (ch.value === void 0 ? idx : ch.value),
              selected: ch && ch.selected,
              disabled: ch && ch.disabled
            };
          });
          this.clear = clear("", this.out.columns);
          if (!opts.overrideRender) {
            this.render();
          }
        }
        reset() {
          this.value.map((v) => !v.selected);
          this.cursor = 0;
          this.fire();
          this.render();
        }
        selected() {
          return this.value.filter((v) => v.selected);
        }
        exit() {
          this.abort();
        }
        abort() {
          this.done = this.aborted = true;
          this.fire();
          this.render();
          this.out.write("\n");
          this.close();
        }
        submit() {
          const selected = this.value.filter((e) => e.selected);
          if (this.minSelected && selected.length < this.minSelected) {
            this.showMinError = true;
            this.render();
          } else {
            this.done = true;
            this.aborted = false;
            this.fire();
            this.render();
            this.out.write("\n");
            this.close();
          }
        }
        first() {
          this.cursor = 0;
          this.render();
        }
        last() {
          this.cursor = this.value.length - 1;
          this.render();
        }
        next() {
          this.cursor = (this.cursor + 1) % this.value.length;
          this.render();
        }
        up() {
          if (this.cursor === 0) {
            this.cursor = this.value.length - 1;
          } else {
            this.cursor--;
          }
          this.render();
        }
        down() {
          if (this.cursor === this.value.length - 1) {
            this.cursor = 0;
          } else {
            this.cursor++;
          }
          this.render();
        }
        left() {
          this.value[this.cursor].selected = false;
          this.render();
        }
        right() {
          if (this.value.filter((e) => e.selected).length >= this.maxChoices)
            return this.bell();
          this.value[this.cursor].selected = true;
          this.render();
        }
        handleSpaceToggle() {
          const v = this.value[this.cursor];
          if (v.selected) {
            v.selected = false;
            this.render();
          } else if (v.disabled || this.value.filter((e) => e.selected).length >= this.maxChoices) {
            return this.bell();
          } else {
            v.selected = true;
            this.render();
          }
        }
        toggleAll() {
          if (this.maxChoices !== void 0 || this.value[this.cursor].disabled) {
            return this.bell();
          }
          const newSelected = !this.value[this.cursor].selected;
          this.value.filter((v) => !v.disabled).forEach((v) => v.selected = newSelected);
          this.render();
        }
        _(c, key) {
          if (c === " ") {
            this.handleSpaceToggle();
          } else if (c === "a") {
            this.toggleAll();
          } else {
            return this.bell();
          }
        }
        renderInstructions() {
          if (this.instructions === void 0 || this.instructions) {
            if (typeof this.instructions === "string") {
              return this.instructions;
            }
            return `
Instructions:
    ${figures.arrowUp}/${figures.arrowDown}: Highlight option
    ${figures.arrowLeft}/${figures.arrowRight}/[space]: Toggle selection
` + (this.maxChoices === void 0 ? `    a: Toggle all
` : "") + `    enter/return: Complete answer`;
          }
          return "";
        }
        renderOption(cursor2, v, i, arrowIndicator) {
          const prefix = (v.selected ? color.green(figures.radioOn) : figures.radioOff) + " " + arrowIndicator + " ";
          let title, desc;
          if (v.disabled) {
            title = cursor2 === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
          } else {
            title = cursor2 === i ? color.cyan().underline(v.title) : v.title;
            if (cursor2 === i && v.description) {
              desc = ` - ${v.description}`;
              if (prefix.length + title.length + desc.length >= this.out.columns || v.description.split(/\r?\n/).length > 1) {
                desc = "\n" + wrap(v.description, {
                  margin: prefix.length,
                  width: this.out.columns
                });
              }
            }
          }
          return prefix + title + color.gray(desc || "");
        }
        paginateOptions(options) {
          if (options.length === 0) {
            return color.red("No matches for this query.");
          }
          let _entriesToDisplay = entriesToDisplay(this.cursor, options.length, this.optionsPerPage), startIndex = _entriesToDisplay.startIndex, endIndex = _entriesToDisplay.endIndex;
          let prefix, styledOptions = [];
          for (let i = startIndex; i < endIndex; i++) {
            if (i === startIndex && startIndex > 0) {
              prefix = figures.arrowUp;
            } else if (i === endIndex - 1 && endIndex < options.length) {
              prefix = figures.arrowDown;
            } else {
              prefix = " ";
            }
            styledOptions.push(this.renderOption(this.cursor, options[i], i, prefix));
          }
          return "\n" + styledOptions.join("\n");
        }
        renderOptions(options) {
          if (!this.done) {
            return this.paginateOptions(options);
          }
          return "";
        }
        renderDoneOrInstructions() {
          if (this.done) {
            return this.value.filter((e) => e.selected).map((v) => v.title).join(", ");
          }
          const output = [color.gray(this.hint), this.renderInstructions()];
          if (this.value[this.cursor].disabled) {
            output.push(color.yellow(this.warn));
          }
          return output.join(" ");
        }
        render() {
          if (this.closed)
            return;
          if (this.firstRender)
            this.out.write(cursor.hide);
          super.render();
          let prompt = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(false), this.renderDoneOrInstructions()].join(" ");
          if (this.showMinError) {
            prompt += color.red(`You must select a minimum of ${this.minSelected} choices.`);
            this.showMinError = false;
          }
          prompt += this.renderOptions(this.value);
          this.out.write(this.clear + prompt);
          this.clear = clear(prompt, this.out.columns);
        }
      };
      module2.exports = MultiselectPrompt;
    });
    var require_autocomplete = __commonJS2((exports2, module2) => {
      "use strict";
      function asyncGeneratorStep(gen, resolve2, reject, _next, _throw, key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }
        if (info.done) {
          resolve2(value);
        } else {
          Promise.resolve(value).then(_next, _throw);
        }
      }
      function _asyncToGenerator(fn) {
        return function() {
          var self = this, args = arguments;
          return new Promise(function(resolve2, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
              asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
              asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "throw", err);
            }
            _next(void 0);
          });
        };
      }
      var color = require_kleur();
      var Prompt = require_prompt();
      var _require = require_src();
      var erase = _require.erase;
      var cursor = _require.cursor;
      var _require2 = require_util();
      var style = _require2.style;
      var clear = _require2.clear;
      var figures = _require2.figures;
      var wrap = _require2.wrap;
      var entriesToDisplay = _require2.entriesToDisplay;
      var getVal = (arr, i) => arr[i] && (arr[i].value || arr[i].title || arr[i]);
      var getTitle = (arr, i) => arr[i] && (arr[i].title || arr[i].value || arr[i]);
      var getIndex = (arr, valOrTitle) => {
        const index = arr.findIndex((el) => el.value === valOrTitle || el.title === valOrTitle);
        return index > -1 ? index : void 0;
      };
      var AutocompletePrompt = class extends Prompt {
        constructor(opts = {}) {
          super(opts);
          this.msg = opts.message;
          this.suggest = opts.suggest;
          this.choices = opts.choices;
          this.initial = typeof opts.initial === "number" ? opts.initial : getIndex(opts.choices, opts.initial);
          this.select = this.initial || opts.cursor || 0;
          this.i18n = {
            noMatches: opts.noMatches || "no matches found"
          };
          this.fallback = opts.fallback || this.initial;
          this.clearFirst = opts.clearFirst || false;
          this.suggestions = [];
          this.input = "";
          this.limit = opts.limit || 10;
          this.cursor = 0;
          this.transform = style.render(opts.style);
          this.scale = this.transform.scale;
          this.render = this.render.bind(this);
          this.complete = this.complete.bind(this);
          this.clear = clear("", this.out.columns);
          this.complete(this.render);
          this.render();
        }
        set fallback(fb) {
          this._fb = Number.isSafeInteger(parseInt(fb)) ? parseInt(fb) : fb;
        }
        get fallback() {
          let choice;
          if (typeof this._fb === "number")
            choice = this.choices[this._fb];
          else if (typeof this._fb === "string")
            choice = {
              title: this._fb
            };
          return choice || this._fb || {
            title: this.i18n.noMatches
          };
        }
        moveSelect(i) {
          this.select = i;
          if (this.suggestions.length > 0)
            this.value = getVal(this.suggestions, i);
          else
            this.value = this.fallback.value;
          this.fire();
        }
        complete(cb) {
          var _this = this;
          return _asyncToGenerator(function* () {
            const p = _this.completing = _this.suggest(_this.input, _this.choices);
            const suggestions = yield p;
            if (_this.completing !== p)
              return;
            _this.suggestions = suggestions.map((s, i, arr) => ({
              title: getTitle(arr, i),
              value: getVal(arr, i),
              description: s.description
            }));
            _this.completing = false;
            const l = Math.max(suggestions.length - 1, 0);
            _this.moveSelect(Math.min(l, _this.select));
            cb && cb();
          })();
        }
        reset() {
          this.input = "";
          this.complete(() => {
            this.moveSelect(this.initial !== void 0 ? this.initial : 0);
            this.render();
          });
          this.render();
        }
        exit() {
          if (this.clearFirst && this.input.length > 0) {
            this.reset();
          } else {
            this.done = this.exited = true;
            this.aborted = false;
            this.fire();
            this.render();
            this.out.write("\n");
            this.close();
          }
        }
        abort() {
          this.done = this.aborted = true;
          this.exited = false;
          this.fire();
          this.render();
          this.out.write("\n");
          this.close();
        }
        submit() {
          this.done = true;
          this.aborted = this.exited = false;
          this.fire();
          this.render();
          this.out.write("\n");
          this.close();
        }
        _(c, key) {
          let s1 = this.input.slice(0, this.cursor);
          let s2 = this.input.slice(this.cursor);
          this.input = `${s1}${c}${s2}`;
          this.cursor = s1.length + 1;
          this.complete(this.render);
          this.render();
        }
        delete() {
          if (this.cursor === 0)
            return this.bell();
          let s1 = this.input.slice(0, this.cursor - 1);
          let s2 = this.input.slice(this.cursor);
          this.input = `${s1}${s2}`;
          this.complete(this.render);
          this.cursor = this.cursor - 1;
          this.render();
        }
        deleteForward() {
          if (this.cursor * this.scale >= this.rendered.length)
            return this.bell();
          let s1 = this.input.slice(0, this.cursor);
          let s2 = this.input.slice(this.cursor + 1);
          this.input = `${s1}${s2}`;
          this.complete(this.render);
          this.render();
        }
        first() {
          this.moveSelect(0);
          this.render();
        }
        last() {
          this.moveSelect(this.suggestions.length - 1);
          this.render();
        }
        up() {
          if (this.select === 0) {
            this.moveSelect(this.suggestions.length - 1);
          } else {
            this.moveSelect(this.select - 1);
          }
          this.render();
        }
        down() {
          if (this.select === this.suggestions.length - 1) {
            this.moveSelect(0);
          } else {
            this.moveSelect(this.select + 1);
          }
          this.render();
        }
        next() {
          if (this.select === this.suggestions.length - 1) {
            this.moveSelect(0);
          } else
            this.moveSelect(this.select + 1);
          this.render();
        }
        nextPage() {
          this.moveSelect(Math.min(this.select + this.limit, this.suggestions.length - 1));
          this.render();
        }
        prevPage() {
          this.moveSelect(Math.max(this.select - this.limit, 0));
          this.render();
        }
        left() {
          if (this.cursor <= 0)
            return this.bell();
          this.cursor = this.cursor - 1;
          this.render();
        }
        right() {
          if (this.cursor * this.scale >= this.rendered.length)
            return this.bell();
          this.cursor = this.cursor + 1;
          this.render();
        }
        renderOption(v, hovered, isStart, isEnd) {
          let desc;
          let prefix = isStart ? figures.arrowUp : isEnd ? figures.arrowDown : " ";
          let title = hovered ? color.cyan().underline(v.title) : v.title;
          prefix = (hovered ? color.cyan(figures.pointer) + " " : "  ") + prefix;
          if (v.description) {
            desc = ` - ${v.description}`;
            if (prefix.length + title.length + desc.length >= this.out.columns || v.description.split(/\r?\n/).length > 1) {
              desc = "\n" + wrap(v.description, {
                margin: 3,
                width: this.out.columns
              });
            }
          }
          return prefix + " " + title + color.gray(desc || "");
        }
        render() {
          if (this.closed)
            return;
          if (this.firstRender)
            this.out.write(cursor.hide);
          else
            this.out.write(clear(this.outputText, this.out.columns));
          super.render();
          let _entriesToDisplay = entriesToDisplay(this.select, this.choices.length, this.limit), startIndex = _entriesToDisplay.startIndex, endIndex = _entriesToDisplay.endIndex;
          this.outputText = [style.symbol(this.done, this.aborted, this.exited), color.bold(this.msg), style.delimiter(this.completing), this.done && this.suggestions[this.select] ? this.suggestions[this.select].title : this.rendered = this.transform.render(this.input)].join(" ");
          if (!this.done) {
            const suggestions = this.suggestions.slice(startIndex, endIndex).map((item, i) => this.renderOption(item, this.select === i + startIndex, i === 0 && startIndex > 0, i + startIndex === endIndex - 1 && endIndex < this.choices.length)).join("\n");
            this.outputText += `
` + (suggestions || color.gray(this.fallback.title));
          }
          this.out.write(erase.line + cursor.to(0) + this.outputText);
        }
      };
      module2.exports = AutocompletePrompt;
    });
    var require_autocompleteMultiselect = __commonJS2((exports2, module2) => {
      "use strict";
      var color = require_kleur();
      var _require = require_src();
      var cursor = _require.cursor;
      var MultiselectPrompt = require_multiselect();
      var _require2 = require_util();
      var clear = _require2.clear;
      var style = _require2.style;
      var figures = _require2.figures;
      var AutocompleteMultiselectPrompt = class extends MultiselectPrompt {
        constructor(opts = {}) {
          opts.overrideRender = true;
          super(opts);
          this.inputValue = "";
          this.clear = clear("", this.out.columns);
          this.filteredOptions = this.value;
          this.render();
        }
        last() {
          this.cursor = this.filteredOptions.length - 1;
          this.render();
        }
        next() {
          this.cursor = (this.cursor + 1) % this.filteredOptions.length;
          this.render();
        }
        up() {
          if (this.cursor === 0) {
            this.cursor = this.filteredOptions.length - 1;
          } else {
            this.cursor--;
          }
          this.render();
        }
        down() {
          if (this.cursor === this.filteredOptions.length - 1) {
            this.cursor = 0;
          } else {
            this.cursor++;
          }
          this.render();
        }
        left() {
          this.filteredOptions[this.cursor].selected = false;
          this.render();
        }
        right() {
          if (this.value.filter((e) => e.selected).length >= this.maxChoices)
            return this.bell();
          this.filteredOptions[this.cursor].selected = true;
          this.render();
        }
        delete() {
          if (this.inputValue.length) {
            this.inputValue = this.inputValue.substr(0, this.inputValue.length - 1);
            this.updateFilteredOptions();
          }
        }
        updateFilteredOptions() {
          const currentHighlight = this.filteredOptions[this.cursor];
          this.filteredOptions = this.value.filter((v) => {
            if (this.inputValue) {
              if (typeof v.title === "string") {
                if (v.title.toLowerCase().includes(this.inputValue.toLowerCase())) {
                  return true;
                }
              }
              if (typeof v.value === "string") {
                if (v.value.toLowerCase().includes(this.inputValue.toLowerCase())) {
                  return true;
                }
              }
              return false;
            }
            return true;
          });
          const newHighlightIndex = this.filteredOptions.findIndex((v) => v === currentHighlight);
          this.cursor = newHighlightIndex < 0 ? 0 : newHighlightIndex;
          this.render();
        }
        handleSpaceToggle() {
          const v = this.filteredOptions[this.cursor];
          if (v.selected) {
            v.selected = false;
            this.render();
          } else if (v.disabled || this.value.filter((e) => e.selected).length >= this.maxChoices) {
            return this.bell();
          } else {
            v.selected = true;
            this.render();
          }
        }
        handleInputChange(c) {
          this.inputValue = this.inputValue + c;
          this.updateFilteredOptions();
        }
        _(c, key) {
          if (c === " ") {
            this.handleSpaceToggle();
          } else {
            this.handleInputChange(c);
          }
        }
        renderInstructions() {
          if (this.instructions === void 0 || this.instructions) {
            if (typeof this.instructions === "string") {
              return this.instructions;
            }
            return `
Instructions:
    ${figures.arrowUp}/${figures.arrowDown}: Highlight option
    ${figures.arrowLeft}/${figures.arrowRight}/[space]: Toggle selection
    [a,b,c]/delete: Filter choices
    enter/return: Complete answer
`;
          }
          return "";
        }
        renderCurrentInput() {
          return `
Filtered results for: ${this.inputValue ? this.inputValue : color.gray("Enter something to filter")}
`;
        }
        renderOption(cursor2, v, i) {
          let title;
          if (v.disabled)
            title = cursor2 === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
          else
            title = cursor2 === i ? color.cyan().underline(v.title) : v.title;
          return (v.selected ? color.green(figures.radioOn) : figures.radioOff) + "  " + title;
        }
        renderDoneOrInstructions() {
          if (this.done) {
            return this.value.filter((e) => e.selected).map((v) => v.title).join(", ");
          }
          const output = [color.gray(this.hint), this.renderInstructions(), this.renderCurrentInput()];
          if (this.filteredOptions.length && this.filteredOptions[this.cursor].disabled) {
            output.push(color.yellow(this.warn));
          }
          return output.join(" ");
        }
        render() {
          if (this.closed)
            return;
          if (this.firstRender)
            this.out.write(cursor.hide);
          super.render();
          let prompt = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(false), this.renderDoneOrInstructions()].join(" ");
          if (this.showMinError) {
            prompt += color.red(`You must select a minimum of ${this.minSelected} choices.`);
            this.showMinError = false;
          }
          prompt += this.renderOptions(this.filteredOptions);
          this.out.write(this.clear + prompt);
          this.clear = clear(prompt, this.out.columns);
        }
      };
      module2.exports = AutocompleteMultiselectPrompt;
    });
    var require_confirm = __commonJS2((exports2, module2) => {
      "use strict";
      var color = require_kleur();
      var Prompt = require_prompt();
      var _require = require_util();
      var style = _require.style;
      var clear = _require.clear;
      var _require2 = require_src();
      var erase = _require2.erase;
      var cursor = _require2.cursor;
      var ConfirmPrompt = class extends Prompt {
        constructor(opts = {}) {
          super(opts);
          this.msg = opts.message;
          this.value = opts.initial;
          this.initialValue = !!opts.initial;
          this.yesMsg = opts.yes || "yes";
          this.yesOption = opts.yesOption || "(Y/n)";
          this.noMsg = opts.no || "no";
          this.noOption = opts.noOption || "(y/N)";
          this.render();
        }
        reset() {
          this.value = this.initialValue;
          this.fire();
          this.render();
        }
        exit() {
          this.abort();
        }
        abort() {
          this.done = this.aborted = true;
          this.fire();
          this.render();
          this.out.write("\n");
          this.close();
        }
        submit() {
          this.value = this.value || false;
          this.done = true;
          this.aborted = false;
          this.fire();
          this.render();
          this.out.write("\n");
          this.close();
        }
        _(c, key) {
          if (c.toLowerCase() === "y") {
            this.value = true;
            return this.submit();
          }
          if (c.toLowerCase() === "n") {
            this.value = false;
            return this.submit();
          }
          return this.bell();
        }
        render() {
          if (this.closed)
            return;
          if (this.firstRender)
            this.out.write(cursor.hide);
          else
            this.out.write(clear(this.outputText, this.out.columns));
          super.render();
          this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(this.done), this.done ? this.value ? this.yesMsg : this.noMsg : color.gray(this.initialValue ? this.yesOption : this.noOption)].join(" ");
          this.out.write(erase.line + cursor.to(0) + this.outputText);
        }
      };
      module2.exports = ConfirmPrompt;
    });
    var require_elements = __commonJS2((exports2, module2) => {
      "use strict";
      module2.exports = {
        TextPrompt: require_text(),
        SelectPrompt: require_select(),
        TogglePrompt: require_toggle(),
        DatePrompt: require_date(),
        NumberPrompt: require_number(),
        MultiselectPrompt: require_multiselect(),
        AutocompletePrompt: require_autocomplete(),
        AutocompleteMultiselectPrompt: require_autocompleteMultiselect(),
        ConfirmPrompt: require_confirm()
      };
    });
    var require_prompts = __commonJS2((exports2) => {
      "use strict";
      var $ = exports2;
      var el = require_elements();
      var noop = (v) => v;
      function toPrompt(type, args, opts = {}) {
        return new Promise((res, rej) => {
          const p = new el[type](args);
          const onAbort = opts.onAbort || noop;
          const onSubmit = opts.onSubmit || noop;
          const onExit = opts.onExit || noop;
          p.on("state", args.onState || noop);
          p.on("submit", (x) => res(onSubmit(x)));
          p.on("exit", (x) => res(onExit(x)));
          p.on("abort", (x) => rej(onAbort(x)));
        });
      }
      $.text = (args) => toPrompt("TextPrompt", args);
      $.password = (args) => {
        args.style = "password";
        return $.text(args);
      };
      $.invisible = (args) => {
        args.style = "invisible";
        return $.text(args);
      };
      $.number = (args) => toPrompt("NumberPrompt", args);
      $.date = (args) => toPrompt("DatePrompt", args);
      $.confirm = (args) => toPrompt("ConfirmPrompt", args);
      $.list = (args) => {
        const sep = args.separator || ",";
        return toPrompt("TextPrompt", args, {
          onSubmit: (str) => str.split(sep).map((s) => s.trim())
        });
      };
      $.toggle = (args) => toPrompt("TogglePrompt", args);
      $.select = (args) => toPrompt("SelectPrompt", args);
      $.multiselect = (args) => {
        args.choices = [].concat(args.choices || []);
        const toSelected = (items) => items.filter((item) => item.selected).map((item) => item.value);
        return toPrompt("MultiselectPrompt", args, {
          onAbort: toSelected,
          onSubmit: toSelected
        });
      };
      $.autocompleteMultiselect = (args) => {
        args.choices = [].concat(args.choices || []);
        const toSelected = (items) => items.filter((item) => item.selected).map((item) => item.value);
        return toPrompt("AutocompleteMultiselectPrompt", args, {
          onAbort: toSelected,
          onSubmit: toSelected
        });
      };
      var byTitle = (input, choices) => Promise.resolve(choices.filter((item) => item.title.slice(0, input.length).toLowerCase() === input.toLowerCase()));
      $.autocomplete = (args) => {
        args.suggest = args.suggest || byTitle;
        args.choices = [].concat(args.choices || []);
        return toPrompt("AutocompletePrompt", args);
      };
    });
    var require_dist2 = __commonJS2((exports2, module2) => {
      "use strict";
      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys.push.apply(keys, symbols);
        }
        return keys;
      }
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _createForOfIteratorHelper(o, allowArrayLike) {
        var it;
        if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
          if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it)
              o = it;
            var i = 0;
            var F = function F2() {
            };
            return { s: F, n: function n() {
              if (i >= o.length)
                return { done: true };
              return { done: false, value: o[i++] };
            }, e: function e(_e) {
              throw _e;
            }, f: F };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var normalCompletion = true, didErr = false, err;
        return { s: function s() {
          it = o[Symbol.iterator]();
        }, n: function n() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        }, e: function e(_e2) {
          didErr = true;
          err = _e2;
        }, f: function f() {
          try {
            if (!normalCompletion && it.return != null)
              it.return();
          } finally {
            if (didErr)
              throw err;
          }
        } };
      }
      function _unsupportedIterableToArray(o, minLen) {
        if (!o)
          return;
        if (typeof o === "string")
          return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor)
          n = o.constructor.name;
        if (n === "Map" || n === "Set")
          return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _arrayLikeToArray(o, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++)
          arr2[i] = arr[i];
        return arr2;
      }
      function asyncGeneratorStep(gen, resolve2, reject, _next, _throw, key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }
        if (info.done) {
          resolve2(value);
        } else {
          Promise.resolve(value).then(_next, _throw);
        }
      }
      function _asyncToGenerator(fn) {
        return function() {
          var self = this, args = arguments;
          return new Promise(function(resolve2, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
              asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
              asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "throw", err);
            }
            _next(void 0);
          });
        };
      }
      var prompts3 = require_prompts();
      var passOn = ["suggest", "format", "onState", "validate", "onRender", "type"];
      var noop = () => {
      };
      function prompt() {
        return _prompt.apply(this, arguments);
      }
      function _prompt() {
        _prompt = _asyncToGenerator(function* (questions = [], {
          onSubmit = noop,
          onCancel = noop
        } = {}) {
          const answers = {};
          const override2 = prompt._override || {};
          questions = [].concat(questions);
          let answer, question, quit, name, type, lastPrompt;
          const getFormattedAnswer = /* @__PURE__ */ function() {
            var _ref = _asyncToGenerator(function* (question2, answer2, skipValidation = false) {
              if (!skipValidation && question2.validate && question2.validate(answer2) !== true) {
                return;
              }
              return question2.format ? yield question2.format(answer2, answers) : answer2;
            });
            return function getFormattedAnswer2(_x, _x2) {
              return _ref.apply(this, arguments);
            };
          }();
          var _iterator = _createForOfIteratorHelper(questions), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              question = _step.value;
              var _question = question;
              name = _question.name;
              type = _question.type;
              if (typeof type === "function") {
                type = yield type(answer, _objectSpread({}, answers), question);
                question["type"] = type;
              }
              if (!type)
                continue;
              for (let key in question) {
                if (passOn.includes(key))
                  continue;
                let value = question[key];
                question[key] = typeof value === "function" ? yield value(answer, _objectSpread({}, answers), lastPrompt) : value;
              }
              lastPrompt = question;
              if (typeof question.message !== "string") {
                throw new Error("prompt message is required");
              }
              var _question2 = question;
              name = _question2.name;
              type = _question2.type;
              if (prompts3[type] === void 0) {
                throw new Error(`prompt type (${type}) is not defined`);
              }
              if (override2[question.name] !== void 0) {
                answer = yield getFormattedAnswer(question, override2[question.name]);
                if (answer !== void 0) {
                  answers[name] = answer;
                  continue;
                }
              }
              try {
                answer = prompt._injected ? getInjectedAnswer(prompt._injected, question.initial) : yield prompts3[type](question);
                answers[name] = answer = yield getFormattedAnswer(question, answer, true);
                quit = yield onSubmit(question, answer, answers);
              } catch (err) {
                quit = !(yield onCancel(question, answers));
              }
              if (quit)
                return answers;
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          return answers;
        });
        return _prompt.apply(this, arguments);
      }
      function getInjectedAnswer(injected, deafultValue) {
        const answer = injected.shift();
        if (answer instanceof Error) {
          throw answer;
        }
        return answer === void 0 ? deafultValue : answer;
      }
      function inject(answers) {
        prompt._injected = (prompt._injected || []).concat(answers);
      }
      function override(answers) {
        prompt._override = Object.assign({}, answers);
      }
      module2.exports = Object.assign(prompt, {
        prompt,
        prompts: prompts3,
        inject,
        override
      });
    });
    var require_action2 = __commonJS2((exports2, module2) => {
      "use strict";
      module2.exports = (key, isSelect) => {
        if (key.meta && key.name !== "escape")
          return;
        if (key.ctrl) {
          if (key.name === "a")
            return "first";
          if (key.name === "c")
            return "abort";
          if (key.name === "d")
            return "abort";
          if (key.name === "e")
            return "last";
          if (key.name === "g")
            return "reset";
        }
        if (isSelect) {
          if (key.name === "j")
            return "down";
          if (key.name === "k")
            return "up";
        }
        if (key.name === "return")
          return "submit";
        if (key.name === "enter")
          return "submit";
        if (key.name === "backspace")
          return "delete";
        if (key.name === "delete")
          return "deleteForward";
        if (key.name === "abort")
          return "abort";
        if (key.name === "escape")
          return "exit";
        if (key.name === "tab")
          return "next";
        if (key.name === "pagedown")
          return "nextPage";
        if (key.name === "pageup")
          return "prevPage";
        if (key.name === "home")
          return "home";
        if (key.name === "end")
          return "end";
        if (key.name === "up")
          return "up";
        if (key.name === "down")
          return "down";
        if (key.name === "right")
          return "right";
        if (key.name === "left")
          return "left";
        return false;
      };
    });
    var require_strip2 = __commonJS2((exports2, module2) => {
      "use strict";
      module2.exports = (str) => {
        const pattern = [
          "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[a-zA-Z\\d]*)*)?\\u0007)",
          "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))"
        ].join("|");
        const RGX = new RegExp(pattern, "g");
        return typeof str === "string" ? str.replace(RGX, "") : str;
      };
    });
    var require_clear2 = __commonJS2((exports2, module2) => {
      "use strict";
      var strip = require_strip2();
      var { erase, cursor } = require_src();
      var width = (str) => [...strip(str)].length;
      module2.exports = function(prompt, perLine) {
        if (!perLine)
          return erase.line + cursor.to(0);
        let rows = 0;
        const lines = prompt.split(/\r?\n/);
        for (let line of lines) {
          rows += 1 + Math.floor(Math.max(width(line) - 1, 0) / perLine);
        }
        return erase.lines(rows);
      };
    });
    var require_figures2 = __commonJS2((exports2, module2) => {
      "use strict";
      var main = {
        arrowUp: "\u2191",
        arrowDown: "\u2193",
        arrowLeft: "\u2190",
        arrowRight: "\u2192",
        radioOn: "\u25C9",
        radioOff: "\u25EF",
        tick: "\u2714",
        cross: "\u2716",
        ellipsis: "\u2026",
        pointerSmall: "\u203A",
        line: "\u2500",
        pointer: "\u276F"
      };
      var win = {
        arrowUp: main.arrowUp,
        arrowDown: main.arrowDown,
        arrowLeft: main.arrowLeft,
        arrowRight: main.arrowRight,
        radioOn: "(*)",
        radioOff: "( )",
        tick: "\u221A",
        cross: "\xD7",
        ellipsis: "...",
        pointerSmall: "\xBB",
        line: "\u2500",
        pointer: ">"
      };
      var figures = process.platform === "win32" ? win : main;
      module2.exports = figures;
    });
    var require_style2 = __commonJS2((exports2, module2) => {
      "use strict";
      var c = require_kleur();
      var figures = require_figures2();
      var styles = Object.freeze({
        password: { scale: 1, render: (input) => "*".repeat(input.length) },
        emoji: { scale: 2, render: (input) => "\u{1F603}".repeat(input.length) },
        invisible: { scale: 0, render: (input) => "" },
        default: { scale: 1, render: (input) => `${input}` }
      });
      var render = (type) => styles[type] || styles.default;
      var symbols = Object.freeze({
        aborted: c.red(figures.cross),
        done: c.green(figures.tick),
        exited: c.yellow(figures.cross),
        default: c.cyan("?")
      });
      var symbol = (done, aborted, exited) => aborted ? symbols.aborted : exited ? symbols.exited : done ? symbols.done : symbols.default;
      var delimiter = (completing) => c.gray(completing ? figures.ellipsis : figures.pointerSmall);
      var item = (expandable, expanded) => c.gray(expandable ? expanded ? figures.pointerSmall : "+" : figures.line);
      module2.exports = {
        styles,
        render,
        symbols,
        symbol,
        delimiter,
        item
      };
    });
    var require_lines2 = __commonJS2((exports2, module2) => {
      "use strict";
      var strip = require_strip2();
      module2.exports = function(msg, perLine) {
        let lines = String(strip(msg) || "").split(/\r?\n/);
        if (!perLine)
          return lines.length;
        return lines.map((l) => Math.ceil(l.length / perLine)).reduce((a, b) => a + b);
      };
    });
    var require_wrap2 = __commonJS2((exports2, module2) => {
      "use strict";
      module2.exports = (msg, opts = {}) => {
        const tab = Number.isSafeInteger(parseInt(opts.margin)) ? new Array(parseInt(opts.margin)).fill(" ").join("") : opts.margin || "";
        const width = opts.width;
        return (msg || "").split(/\r?\n/g).map((line) => line.split(/\s+/g).reduce((arr, w) => {
          if (w.length + tab.length >= width || arr[arr.length - 1].length + w.length + 1 < width)
            arr[arr.length - 1] += ` ${w}`;
          else
            arr.push(`${tab}${w}`);
          return arr;
        }, [tab]).join("\n")).join("\n");
      };
    });
    var require_entriesToDisplay2 = __commonJS2((exports2, module2) => {
      "use strict";
      module2.exports = (cursor, total, maxVisible) => {
        maxVisible = maxVisible || total;
        let startIndex = Math.min(total - maxVisible, cursor - Math.floor(maxVisible / 2));
        if (startIndex < 0)
          startIndex = 0;
        let endIndex = Math.min(startIndex + maxVisible, total);
        return { startIndex, endIndex };
      };
    });
    var require_util2 = __commonJS2((exports2, module2) => {
      "use strict";
      module2.exports = {
        action: require_action2(),
        clear: require_clear2(),
        style: require_style2(),
        strip: require_strip2(),
        figures: require_figures2(),
        lines: require_lines2(),
        wrap: require_wrap2(),
        entriesToDisplay: require_entriesToDisplay2()
      };
    });
    var require_prompt2 = __commonJS2((exports2, module2) => {
      "use strict";
      var readline = _chunkKRCSYS75js.__require.call(void 0, "readline");
      var { action } = require_util2();
      var EventEmitter = _chunkKRCSYS75js.__require.call(void 0, "events");
      var { beep, cursor } = require_src();
      var color = require_kleur();
      var Prompt = class extends EventEmitter {
        constructor(opts = {}) {
          super();
          this.firstRender = true;
          this.in = opts.stdin || process.stdin;
          this.out = opts.stdout || process.stdout;
          this.onRender = (opts.onRender || (() => void 0)).bind(this);
          const rl = readline.createInterface({ input: this.in, escapeCodeTimeout: 50 });
          readline.emitKeypressEvents(this.in, rl);
          if (this.in.isTTY)
            this.in.setRawMode(true);
          const isSelect = ["SelectPrompt", "MultiselectPrompt"].indexOf(this.constructor.name) > -1;
          const keypress = (str, key) => {
            let a = action(key, isSelect);
            if (a === false) {
              this._ && this._(str, key);
            } else if (typeof this[a] === "function") {
              this[a](key);
            } else {
              this.bell();
            }
          };
          this.close = () => {
            this.out.write(cursor.show);
            this.in.removeListener("keypress", keypress);
            if (this.in.isTTY)
              this.in.setRawMode(false);
            rl.close();
            this.emit(this.aborted ? "abort" : this.exited ? "exit" : "submit", this.value);
            this.closed = true;
          };
          this.in.on("keypress", keypress);
        }
        fire() {
          this.emit("state", {
            value: this.value,
            aborted: !!this.aborted,
            exited: !!this.exited
          });
        }
        bell() {
          this.out.write(beep);
        }
        render() {
          this.onRender(color);
          if (this.firstRender)
            this.firstRender = false;
        }
      };
      module2.exports = Prompt;
    });
    var require_text2 = __commonJS2((exports2, module2) => {
      var color = require_kleur();
      var Prompt = require_prompt2();
      var { erase, cursor } = require_src();
      var { style, clear, lines, figures } = require_util2();
      var TextPrompt = class extends Prompt {
        constructor(opts = {}) {
          super(opts);
          this.transform = style.render(opts.style);
          this.scale = this.transform.scale;
          this.msg = opts.message;
          this.initial = opts.initial || ``;
          this.validator = opts.validate || (() => true);
          this.value = ``;
          this.errorMsg = opts.error || `Please Enter A Valid Value`;
          this.cursor = Number(!!this.initial);
          this.cursorOffset = 0;
          this.clear = clear(``, this.out.columns);
          this.render();
        }
        set value(v) {
          if (!v && this.initial) {
            this.placeholder = true;
            this.rendered = color.gray(this.transform.render(this.initial));
          } else {
            this.placeholder = false;
            this.rendered = this.transform.render(v);
          }
          this._value = v;
          this.fire();
        }
        get value() {
          return this._value;
        }
        reset() {
          this.value = ``;
          this.cursor = Number(!!this.initial);
          this.cursorOffset = 0;
          this.fire();
          this.render();
        }
        exit() {
          this.abort();
        }
        abort() {
          this.value = this.value || this.initial;
          this.done = this.aborted = true;
          this.error = false;
          this.red = false;
          this.fire();
          this.render();
          this.out.write("\n");
          this.close();
        }
        async validate() {
          let valid = await this.validator(this.value);
          if (typeof valid === `string`) {
            this.errorMsg = valid;
            valid = false;
          }
          this.error = !valid;
        }
        async submit() {
          this.value = this.value || this.initial;
          this.cursorOffset = 0;
          this.cursor = this.rendered.length;
          await this.validate();
          if (this.error) {
            this.red = true;
            this.fire();
            this.render();
            return;
          }
          this.done = true;
          this.aborted = false;
          this.fire();
          this.render();
          this.out.write("\n");
          this.close();
        }
        next() {
          if (!this.placeholder)
            return this.bell();
          this.value = this.initial;
          this.cursor = this.rendered.length;
          this.fire();
          this.render();
        }
        moveCursor(n) {
          if (this.placeholder)
            return;
          this.cursor = this.cursor + n;
          this.cursorOffset += n;
        }
        _(c, key) {
          let s1 = this.value.slice(0, this.cursor);
          let s2 = this.value.slice(this.cursor);
          this.value = `${s1}${c}${s2}`;
          this.red = false;
          this.cursor = this.placeholder ? 0 : s1.length + 1;
          this.render();
        }
        delete() {
          if (this.isCursorAtStart())
            return this.bell();
          let s1 = this.value.slice(0, this.cursor - 1);
          let s2 = this.value.slice(this.cursor);
          this.value = `${s1}${s2}`;
          this.red = false;
          if (this.isCursorAtStart()) {
            this.cursorOffset = 0;
          } else {
            this.cursorOffset++;
            this.moveCursor(-1);
          }
          this.render();
        }
        deleteForward() {
          if (this.cursor * this.scale >= this.rendered.length || this.placeholder)
            return this.bell();
          let s1 = this.value.slice(0, this.cursor);
          let s2 = this.value.slice(this.cursor + 1);
          this.value = `${s1}${s2}`;
          this.red = false;
          if (this.isCursorAtEnd()) {
            this.cursorOffset = 0;
          } else {
            this.cursorOffset++;
          }
          this.render();
        }
        first() {
          this.cursor = 0;
          this.render();
        }
        last() {
          this.cursor = this.value.length;
          this.render();
        }
        left() {
          if (this.cursor <= 0 || this.placeholder)
            return this.bell();
          this.moveCursor(-1);
          this.render();
        }
        right() {
          if (this.cursor * this.scale >= this.rendered.length || this.placeholder)
            return this.bell();
          this.moveCursor(1);
          this.render();
        }
        isCursorAtStart() {
          return this.cursor === 0 || this.placeholder && this.cursor === 1;
        }
        isCursorAtEnd() {
          return this.cursor === this.rendered.length || this.placeholder && this.cursor === this.rendered.length + 1;
        }
        render() {
          if (this.closed)
            return;
          if (!this.firstRender) {
            if (this.outputError)
              this.out.write(cursor.down(lines(this.outputError, this.out.columns) - 1) + clear(this.outputError, this.out.columns));
            this.out.write(clear(this.outputText, this.out.columns));
          }
          super.render();
          this.outputError = "";
          this.outputText = [
            style.symbol(this.done, this.aborted),
            color.bold(this.msg),
            style.delimiter(this.done),
            this.red ? color.red(this.rendered) : this.rendered
          ].join(` `);
          if (this.error) {
            this.outputError += this.errorMsg.split(`
`).reduce((a, l, i) => a + `
${i ? " " : figures.pointerSmall} ${color.red().italic(l)}`, ``);
          }
          this.out.write(erase.line + cursor.to(0) + this.outputText + cursor.save + this.outputError + cursor.restore + cursor.move(this.cursorOffset, 0));
        }
      };
      module2.exports = TextPrompt;
    });
    var require_select2 = __commonJS2((exports2, module2) => {
      "use strict";
      var color = require_kleur();
      var Prompt = require_prompt2();
      var { style, clear, figures, wrap, entriesToDisplay } = require_util2();
      var { cursor } = require_src();
      var SelectPrompt = class extends Prompt {
        constructor(opts = {}) {
          super(opts);
          this.msg = opts.message;
          this.hint = opts.hint || "- Use arrow-keys. Return to submit.";
          this.warn = opts.warn || "- This option is disabled";
          this.cursor = opts.initial || 0;
          this.choices = opts.choices.map((ch, idx) => {
            if (typeof ch === "string")
              ch = { title: ch, value: idx };
            return {
              title: ch && (ch.title || ch.value || ch),
              value: ch && (ch.value === void 0 ? idx : ch.value),
              description: ch && ch.description,
              selected: ch && ch.selected,
              disabled: ch && ch.disabled
            };
          });
          this.optionsPerPage = opts.optionsPerPage || 10;
          this.value = (this.choices[this.cursor] || {}).value;
          this.clear = clear("", this.out.columns);
          this.render();
        }
        moveCursor(n) {
          this.cursor = n;
          this.value = this.choices[n].value;
          this.fire();
        }
        reset() {
          this.moveCursor(0);
          this.fire();
          this.render();
        }
        exit() {
          this.abort();
        }
        abort() {
          this.done = this.aborted = true;
          this.fire();
          this.render();
          this.out.write("\n");
          this.close();
        }
        submit() {
          if (!this.selection.disabled) {
            this.done = true;
            this.aborted = false;
            this.fire();
            this.render();
            this.out.write("\n");
            this.close();
          } else
            this.bell();
        }
        first() {
          this.moveCursor(0);
          this.render();
        }
        last() {
          this.moveCursor(this.choices.length - 1);
          this.render();
        }
        up() {
          if (this.cursor === 0) {
            this.moveCursor(this.choices.length - 1);
          } else {
            this.moveCursor(this.cursor - 1);
          }
          this.render();
        }
        down() {
          if (this.cursor === this.choices.length - 1) {
            this.moveCursor(0);
          } else {
            this.moveCursor(this.cursor + 1);
          }
          this.render();
        }
        next() {
          this.moveCursor((this.cursor + 1) % this.choices.length);
          this.render();
        }
        _(c, key) {
          if (c === " ")
            return this.submit();
        }
        get selection() {
          return this.choices[this.cursor];
        }
        render() {
          if (this.closed)
            return;
          if (this.firstRender)
            this.out.write(cursor.hide);
          else
            this.out.write(clear(this.outputText, this.out.columns));
          super.render();
          let { startIndex, endIndex } = entriesToDisplay(this.cursor, this.choices.length, this.optionsPerPage);
          this.outputText = [
            style.symbol(this.done, this.aborted),
            color.bold(this.msg),
            style.delimiter(false),
            this.done ? this.selection.title : this.selection.disabled ? color.yellow(this.warn) : color.gray(this.hint)
          ].join(" ");
          if (!this.done) {
            this.outputText += "\n";
            for (let i = startIndex; i < endIndex; i++) {
              let title, prefix, desc = "", v = this.choices[i];
              if (i === startIndex && startIndex > 0) {
                prefix = figures.arrowUp;
              } else if (i === endIndex - 1 && endIndex < this.choices.length) {
                prefix = figures.arrowDown;
              } else {
                prefix = " ";
              }
              if (v.disabled) {
                title = this.cursor === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
                prefix = (this.cursor === i ? color.bold().gray(figures.pointer) + " " : "  ") + prefix;
              } else {
                title = this.cursor === i ? color.cyan().underline(v.title) : v.title;
                prefix = (this.cursor === i ? color.cyan(figures.pointer) + " " : "  ") + prefix;
                if (v.description && this.cursor === i) {
                  desc = ` - ${v.description}`;
                  if (prefix.length + title.length + desc.length >= this.out.columns || v.description.split(/\r?\n/).length > 1) {
                    desc = "\n" + wrap(v.description, { margin: 3, width: this.out.columns });
                  }
                }
              }
              this.outputText += `${prefix} ${title}${color.gray(desc)}
`;
            }
          }
          this.out.write(this.outputText);
        }
      };
      module2.exports = SelectPrompt;
    });
    var require_toggle2 = __commonJS2((exports2, module2) => {
      var color = require_kleur();
      var Prompt = require_prompt2();
      var { style, clear } = require_util2();
      var { cursor, erase } = require_src();
      var TogglePrompt = class extends Prompt {
        constructor(opts = {}) {
          super(opts);
          this.msg = opts.message;
          this.value = !!opts.initial;
          this.active = opts.active || "on";
          this.inactive = opts.inactive || "off";
          this.initialValue = this.value;
          this.render();
        }
        reset() {
          this.value = this.initialValue;
          this.fire();
          this.render();
        }
        exit() {
          this.abort();
        }
        abort() {
          this.done = this.aborted = true;
          this.fire();
          this.render();
          this.out.write("\n");
          this.close();
        }
        submit() {
          this.done = true;
          this.aborted = false;
          this.fire();
          this.render();
          this.out.write("\n");
          this.close();
        }
        deactivate() {
          if (this.value === false)
            return this.bell();
          this.value = false;
          this.render();
        }
        activate() {
          if (this.value === true)
            return this.bell();
          this.value = true;
          this.render();
        }
        delete() {
          this.deactivate();
        }
        left() {
          this.deactivate();
        }
        right() {
          this.activate();
        }
        down() {
          this.deactivate();
        }
        up() {
          this.activate();
        }
        next() {
          this.value = !this.value;
          this.fire();
          this.render();
        }
        _(c, key) {
          if (c === " ") {
            this.value = !this.value;
          } else if (c === "1") {
            this.value = true;
          } else if (c === "0") {
            this.value = false;
          } else
            return this.bell();
          this.render();
        }
        render() {
          if (this.closed)
            return;
          if (this.firstRender)
            this.out.write(cursor.hide);
          else
            this.out.write(clear(this.outputText, this.out.columns));
          super.render();
          this.outputText = [
            style.symbol(this.done, this.aborted),
            color.bold(this.msg),
            style.delimiter(this.done),
            this.value ? this.inactive : color.cyan().underline(this.inactive),
            color.gray("/"),
            this.value ? color.cyan().underline(this.active) : this.active
          ].join(" ");
          this.out.write(erase.line + cursor.to(0) + this.outputText);
        }
      };
      module2.exports = TogglePrompt;
    });
    var require_datepart2 = __commonJS2((exports2, module2) => {
      "use strict";
      var DatePart = class {
        constructor({ token, date, parts, locales }) {
          this.token = token;
          this.date = date || new Date();
          this.parts = parts || [this];
          this.locales = locales || {};
        }
        up() {
        }
        down() {
        }
        next() {
          const currentIdx = this.parts.indexOf(this);
          return this.parts.find((part, idx) => idx > currentIdx && part instanceof DatePart);
        }
        setTo(val) {
        }
        prev() {
          let parts = [].concat(this.parts).reverse();
          const currentIdx = parts.indexOf(this);
          return parts.find((part, idx) => idx > currentIdx && part instanceof DatePart);
        }
        toString() {
          return String(this.date);
        }
      };
      module2.exports = DatePart;
    });
    var require_meridiem2 = __commonJS2((exports2, module2) => {
      "use strict";
      var DatePart = require_datepart2();
      var Meridiem = class extends DatePart {
        constructor(opts = {}) {
          super(opts);
        }
        up() {
          this.date.setHours((this.date.getHours() + 12) % 24);
        }
        down() {
          this.up();
        }
        toString() {
          let meridiem = this.date.getHours() > 12 ? "pm" : "am";
          return /\A/.test(this.token) ? meridiem.toUpperCase() : meridiem;
        }
      };
      module2.exports = Meridiem;
    });
    var require_day2 = __commonJS2((exports2, module2) => {
      "use strict";
      var DatePart = require_datepart2();
      var pos = (n) => {
        n = n % 10;
        return n === 1 ? "st" : n === 2 ? "nd" : n === 3 ? "rd" : "th";
      };
      var Day = class extends DatePart {
        constructor(opts = {}) {
          super(opts);
        }
        up() {
          this.date.setDate(this.date.getDate() + 1);
        }
        down() {
          this.date.setDate(this.date.getDate() - 1);
        }
        setTo(val) {
          this.date.setDate(parseInt(val.substr(-2)));
        }
        toString() {
          let date = this.date.getDate();
          let day = this.date.getDay();
          return this.token === "DD" ? String(date).padStart(2, "0") : this.token === "Do" ? date + pos(date) : this.token === "d" ? day + 1 : this.token === "ddd" ? this.locales.weekdaysShort[day] : this.token === "dddd" ? this.locales.weekdays[day] : date;
        }
      };
      module2.exports = Day;
    });
    var require_hours2 = __commonJS2((exports2, module2) => {
      "use strict";
      var DatePart = require_datepart2();
      var Hours = class extends DatePart {
        constructor(opts = {}) {
          super(opts);
        }
        up() {
          this.date.setHours(this.date.getHours() + 1);
        }
        down() {
          this.date.setHours(this.date.getHours() - 1);
        }
        setTo(val) {
          this.date.setHours(parseInt(val.substr(-2)));
        }
        toString() {
          let hours = this.date.getHours();
          if (/h/.test(this.token))
            hours = hours % 12 || 12;
          return this.token.length > 1 ? String(hours).padStart(2, "0") : hours;
        }
      };
      module2.exports = Hours;
    });
    var require_milliseconds2 = __commonJS2((exports2, module2) => {
      "use strict";
      var DatePart = require_datepart2();
      var Milliseconds = class extends DatePart {
        constructor(opts = {}) {
          super(opts);
        }
        up() {
          this.date.setMilliseconds(this.date.getMilliseconds() + 1);
        }
        down() {
          this.date.setMilliseconds(this.date.getMilliseconds() - 1);
        }
        setTo(val) {
          this.date.setMilliseconds(parseInt(val.substr(-this.token.length)));
        }
        toString() {
          return String(this.date.getMilliseconds()).padStart(4, "0").substr(0, this.token.length);
        }
      };
      module2.exports = Milliseconds;
    });
    var require_minutes2 = __commonJS2((exports2, module2) => {
      "use strict";
      var DatePart = require_datepart2();
      var Minutes = class extends DatePart {
        constructor(opts = {}) {
          super(opts);
        }
        up() {
          this.date.setMinutes(this.date.getMinutes() + 1);
        }
        down() {
          this.date.setMinutes(this.date.getMinutes() - 1);
        }
        setTo(val) {
          this.date.setMinutes(parseInt(val.substr(-2)));
        }
        toString() {
          let m = this.date.getMinutes();
          return this.token.length > 1 ? String(m).padStart(2, "0") : m;
        }
      };
      module2.exports = Minutes;
    });
    var require_month2 = __commonJS2((exports2, module2) => {
      "use strict";
      var DatePart = require_datepart2();
      var Month = class extends DatePart {
        constructor(opts = {}) {
          super(opts);
        }
        up() {
          this.date.setMonth(this.date.getMonth() + 1);
        }
        down() {
          this.date.setMonth(this.date.getMonth() - 1);
        }
        setTo(val) {
          val = parseInt(val.substr(-2)) - 1;
          this.date.setMonth(val < 0 ? 0 : val);
        }
        toString() {
          let month = this.date.getMonth();
          let tl = this.token.length;
          return tl === 2 ? String(month + 1).padStart(2, "0") : tl === 3 ? this.locales.monthsShort[month] : tl === 4 ? this.locales.months[month] : String(month + 1);
        }
      };
      module2.exports = Month;
    });
    var require_seconds2 = __commonJS2((exports2, module2) => {
      "use strict";
      var DatePart = require_datepart2();
      var Seconds = class extends DatePart {
        constructor(opts = {}) {
          super(opts);
        }
        up() {
          this.date.setSeconds(this.date.getSeconds() + 1);
        }
        down() {
          this.date.setSeconds(this.date.getSeconds() - 1);
        }
        setTo(val) {
          this.date.setSeconds(parseInt(val.substr(-2)));
        }
        toString() {
          let s = this.date.getSeconds();
          return this.token.length > 1 ? String(s).padStart(2, "0") : s;
        }
      };
      module2.exports = Seconds;
    });
    var require_year2 = __commonJS2((exports2, module2) => {
      "use strict";
      var DatePart = require_datepart2();
      var Year = class extends DatePart {
        constructor(opts = {}) {
          super(opts);
        }
        up() {
          this.date.setFullYear(this.date.getFullYear() + 1);
        }
        down() {
          this.date.setFullYear(this.date.getFullYear() - 1);
        }
        setTo(val) {
          this.date.setFullYear(val.substr(-4));
        }
        toString() {
          let year = String(this.date.getFullYear()).padStart(4, "0");
          return this.token.length === 2 ? year.substr(-2) : year;
        }
      };
      module2.exports = Year;
    });
    var require_dateparts2 = __commonJS2((exports2, module2) => {
      "use strict";
      module2.exports = {
        DatePart: require_datepart2(),
        Meridiem: require_meridiem2(),
        Day: require_day2(),
        Hours: require_hours2(),
        Milliseconds: require_milliseconds2(),
        Minutes: require_minutes2(),
        Month: require_month2(),
        Seconds: require_seconds2(),
        Year: require_year2()
      };
    });
    var require_date2 = __commonJS2((exports2, module2) => {
      "use strict";
      var color = require_kleur();
      var Prompt = require_prompt2();
      var { style, clear, figures } = require_util2();
      var { erase, cursor } = require_src();
      var { DatePart, Meridiem, Day, Hours, Milliseconds, Minutes, Month, Seconds, Year } = require_dateparts2();
      var regex = /\\(.)|"((?:\\["\\]|[^"])+)"|(D[Do]?|d{3,4}|d)|(M{1,4})|(YY(?:YY)?)|([aA])|([Hh]{1,2})|(m{1,2})|(s{1,2})|(S{1,4})|./g;
      var regexGroups = {
        1: ({ token }) => token.replace(/\\(.)/g, "$1"),
        2: (opts) => new Day(opts),
        3: (opts) => new Month(opts),
        4: (opts) => new Year(opts),
        5: (opts) => new Meridiem(opts),
        6: (opts) => new Hours(opts),
        7: (opts) => new Minutes(opts),
        8: (opts) => new Seconds(opts),
        9: (opts) => new Milliseconds(opts)
      };
      var dfltLocales = {
        months: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
        monthsShort: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
        weekdays: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
        weekdaysShort: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(",")
      };
      var DatePrompt = class extends Prompt {
        constructor(opts = {}) {
          super(opts);
          this.msg = opts.message;
          this.cursor = 0;
          this.typed = "";
          this.locales = Object.assign(dfltLocales, opts.locales);
          this._date = opts.initial || new Date();
          this.errorMsg = opts.error || "Please Enter A Valid Value";
          this.validator = opts.validate || (() => true);
          this.mask = opts.mask || "YYYY-MM-DD HH:mm:ss";
          this.clear = clear("", this.out.columns);
          this.render();
        }
        get value() {
          return this.date;
        }
        get date() {
          return this._date;
        }
        set date(date) {
          if (date)
            this._date.setTime(date.getTime());
        }
        set mask(mask) {
          let result;
          this.parts = [];
          while (result = regex.exec(mask)) {
            let match = result.shift();
            let idx = result.findIndex((gr) => gr != null);
            this.parts.push(idx in regexGroups ? regexGroups[idx]({ token: result[idx] || match, date: this.date, parts: this.parts, locales: this.locales }) : result[idx] || match);
          }
          let parts = this.parts.reduce((arr, i) => {
            if (typeof i === "string" && typeof arr[arr.length - 1] === "string")
              arr[arr.length - 1] += i;
            else
              arr.push(i);
            return arr;
          }, []);
          this.parts.splice(0);
          this.parts.push(...parts);
          this.reset();
        }
        moveCursor(n) {
          this.typed = "";
          this.cursor = n;
          this.fire();
        }
        reset() {
          this.moveCursor(this.parts.findIndex((p) => p instanceof DatePart));
          this.fire();
          this.render();
        }
        exit() {
          this.abort();
        }
        abort() {
          this.done = this.aborted = true;
          this.error = false;
          this.fire();
          this.render();
          this.out.write("\n");
          this.close();
        }
        async validate() {
          let valid = await this.validator(this.value);
          if (typeof valid === "string") {
            this.errorMsg = valid;
            valid = false;
          }
          this.error = !valid;
        }
        async submit() {
          await this.validate();
          if (this.error) {
            this.color = "red";
            this.fire();
            this.render();
            return;
          }
          this.done = true;
          this.aborted = false;
          this.fire();
          this.render();
          this.out.write("\n");
          this.close();
        }
        up() {
          this.typed = "";
          this.parts[this.cursor].up();
          this.render();
        }
        down() {
          this.typed = "";
          this.parts[this.cursor].down();
          this.render();
        }
        left() {
          let prev = this.parts[this.cursor].prev();
          if (prev == null)
            return this.bell();
          this.moveCursor(this.parts.indexOf(prev));
          this.render();
        }
        right() {
          let next = this.parts[this.cursor].next();
          if (next == null)
            return this.bell();
          this.moveCursor(this.parts.indexOf(next));
          this.render();
        }
        next() {
          let next = this.parts[this.cursor].next();
          this.moveCursor(next ? this.parts.indexOf(next) : this.parts.findIndex((part) => part instanceof DatePart));
          this.render();
        }
        _(c) {
          if (/\d/.test(c)) {
            this.typed += c;
            this.parts[this.cursor].setTo(this.typed);
            this.render();
          }
        }
        render() {
          if (this.closed)
            return;
          if (this.firstRender)
            this.out.write(cursor.hide);
          else
            this.out.write(clear(this.outputText, this.out.columns));
          super.render();
          this.outputText = [
            style.symbol(this.done, this.aborted),
            color.bold(this.msg),
            style.delimiter(false),
            this.parts.reduce((arr, p, idx) => arr.concat(idx === this.cursor && !this.done ? color.cyan().underline(p.toString()) : p), []).join("")
          ].join(" ");
          if (this.error) {
            this.outputText += this.errorMsg.split("\n").reduce((a, l, i) => a + `
${i ? ` ` : figures.pointerSmall} ${color.red().italic(l)}`, ``);
          }
          this.out.write(erase.line + cursor.to(0) + this.outputText);
        }
      };
      module2.exports = DatePrompt;
    });
    var require_number2 = __commonJS2((exports2, module2) => {
      var color = require_kleur();
      var Prompt = require_prompt2();
      var { cursor, erase } = require_src();
      var { style, figures, clear, lines } = require_util2();
      var isNumber = /[0-9]/;
      var isDef = (any) => any !== void 0;
      var round = (number, precision) => {
        let factor = Math.pow(10, precision);
        return Math.round(number * factor) / factor;
      };
      var NumberPrompt = class extends Prompt {
        constructor(opts = {}) {
          super(opts);
          this.transform = style.render(opts.style);
          this.msg = opts.message;
          this.initial = isDef(opts.initial) ? opts.initial : "";
          this.float = !!opts.float;
          this.round = opts.round || 2;
          this.inc = opts.increment || 1;
          this.min = isDef(opts.min) ? opts.min : -Infinity;
          this.max = isDef(opts.max) ? opts.max : Infinity;
          this.errorMsg = opts.error || `Please Enter A Valid Value`;
          this.validator = opts.validate || (() => true);
          this.color = `cyan`;
          this.value = ``;
          this.typed = ``;
          this.lastHit = 0;
          this.render();
        }
        set value(v) {
          if (!v && v !== 0) {
            this.placeholder = true;
            this.rendered = color.gray(this.transform.render(`${this.initial}`));
            this._value = ``;
          } else {
            this.placeholder = false;
            this.rendered = this.transform.render(`${round(v, this.round)}`);
            this._value = round(v, this.round);
          }
          this.fire();
        }
        get value() {
          return this._value;
        }
        parse(x) {
          return this.float ? parseFloat(x) : parseInt(x);
        }
        valid(c) {
          return c === `-` || c === `.` && this.float || isNumber.test(c);
        }
        reset() {
          this.typed = ``;
          this.value = ``;
          this.fire();
          this.render();
        }
        exit() {
          this.abort();
        }
        abort() {
          let x = this.value;
          this.value = x !== `` ? x : this.initial;
          this.done = this.aborted = true;
          this.error = false;
          this.fire();
          this.render();
          this.out.write(`
`);
          this.close();
        }
        async validate() {
          let valid = await this.validator(this.value);
          if (typeof valid === `string`) {
            this.errorMsg = valid;
            valid = false;
          }
          this.error = !valid;
        }
        async submit() {
          await this.validate();
          if (this.error) {
            this.color = `red`;
            this.fire();
            this.render();
            return;
          }
          let x = this.value;
          this.value = x !== `` ? x : this.initial;
          this.done = true;
          this.aborted = false;
          this.error = false;
          this.fire();
          this.render();
          this.out.write(`
`);
          this.close();
        }
        up() {
          this.typed = ``;
          if (this.value === "") {
            this.value = this.min - this.inc;
          }
          if (this.value >= this.max)
            return this.bell();
          this.value += this.inc;
          this.color = `cyan`;
          this.fire();
          this.render();
        }
        down() {
          this.typed = ``;
          if (this.value === "") {
            this.value = this.min + this.inc;
          }
          if (this.value <= this.min)
            return this.bell();
          this.value -= this.inc;
          this.color = `cyan`;
          this.fire();
          this.render();
        }
        delete() {
          let val = this.value.toString();
          if (val.length === 0)
            return this.bell();
          this.value = this.parse(val = val.slice(0, -1)) || ``;
          if (this.value !== "" && this.value < this.min) {
            this.value = this.min;
          }
          this.color = `cyan`;
          this.fire();
          this.render();
        }
        next() {
          this.value = this.initial;
          this.fire();
          this.render();
        }
        _(c, key) {
          if (!this.valid(c))
            return this.bell();
          const now = Date.now();
          if (now - this.lastHit > 1e3)
            this.typed = ``;
          this.typed += c;
          this.lastHit = now;
          this.color = `cyan`;
          if (c === `.`)
            return this.fire();
          this.value = Math.min(this.parse(this.typed), this.max);
          if (this.value > this.max)
            this.value = this.max;
          if (this.value < this.min)
            this.value = this.min;
          this.fire();
          this.render();
        }
        render() {
          if (this.closed)
            return;
          if (!this.firstRender) {
            if (this.outputError)
              this.out.write(cursor.down(lines(this.outputError, this.out.columns) - 1) + clear(this.outputError, this.out.columns));
            this.out.write(clear(this.outputText, this.out.columns));
          }
          super.render();
          this.outputError = "";
          this.outputText = [
            style.symbol(this.done, this.aborted),
            color.bold(this.msg),
            style.delimiter(this.done),
            !this.done || !this.done && !this.placeholder ? color[this.color]().underline(this.rendered) : this.rendered
          ].join(` `);
          if (this.error) {
            this.outputError += this.errorMsg.split(`
`).reduce((a, l, i) => a + `
${i ? ` ` : figures.pointerSmall} ${color.red().italic(l)}`, ``);
          }
          this.out.write(erase.line + cursor.to(0) + this.outputText + cursor.save + this.outputError + cursor.restore);
        }
      };
      module2.exports = NumberPrompt;
    });
    var require_multiselect2 = __commonJS2((exports2, module2) => {
      "use strict";
      var color = require_kleur();
      var { cursor } = require_src();
      var Prompt = require_prompt2();
      var { clear, figures, style, wrap, entriesToDisplay } = require_util2();
      var MultiselectPrompt = class extends Prompt {
        constructor(opts = {}) {
          super(opts);
          this.msg = opts.message;
          this.cursor = opts.cursor || 0;
          this.scrollIndex = opts.cursor || 0;
          this.hint = opts.hint || "";
          this.warn = opts.warn || "- This option is disabled -";
          this.minSelected = opts.min;
          this.showMinError = false;
          this.maxChoices = opts.max;
          this.instructions = opts.instructions;
          this.optionsPerPage = opts.optionsPerPage || 10;
          this.value = opts.choices.map((ch, idx) => {
            if (typeof ch === "string")
              ch = { title: ch, value: idx };
            return {
              title: ch && (ch.title || ch.value || ch),
              description: ch && ch.description,
              value: ch && (ch.value === void 0 ? idx : ch.value),
              selected: ch && ch.selected,
              disabled: ch && ch.disabled
            };
          });
          this.clear = clear("", this.out.columns);
          if (!opts.overrideRender) {
            this.render();
          }
        }
        reset() {
          this.value.map((v) => !v.selected);
          this.cursor = 0;
          this.fire();
          this.render();
        }
        selected() {
          return this.value.filter((v) => v.selected);
        }
        exit() {
          this.abort();
        }
        abort() {
          this.done = this.aborted = true;
          this.fire();
          this.render();
          this.out.write("\n");
          this.close();
        }
        submit() {
          const selected = this.value.filter((e) => e.selected);
          if (this.minSelected && selected.length < this.minSelected) {
            this.showMinError = true;
            this.render();
          } else {
            this.done = true;
            this.aborted = false;
            this.fire();
            this.render();
            this.out.write("\n");
            this.close();
          }
        }
        first() {
          this.cursor = 0;
          this.render();
        }
        last() {
          this.cursor = this.value.length - 1;
          this.render();
        }
        next() {
          this.cursor = (this.cursor + 1) % this.value.length;
          this.render();
        }
        up() {
          if (this.cursor === 0) {
            this.cursor = this.value.length - 1;
          } else {
            this.cursor--;
          }
          this.render();
        }
        down() {
          if (this.cursor === this.value.length - 1) {
            this.cursor = 0;
          } else {
            this.cursor++;
          }
          this.render();
        }
        left() {
          this.value[this.cursor].selected = false;
          this.render();
        }
        right() {
          if (this.value.filter((e) => e.selected).length >= this.maxChoices)
            return this.bell();
          this.value[this.cursor].selected = true;
          this.render();
        }
        handleSpaceToggle() {
          const v = this.value[this.cursor];
          if (v.selected) {
            v.selected = false;
            this.render();
          } else if (v.disabled || this.value.filter((e) => e.selected).length >= this.maxChoices) {
            return this.bell();
          } else {
            v.selected = true;
            this.render();
          }
        }
        toggleAll() {
          if (this.maxChoices !== void 0 || this.value[this.cursor].disabled) {
            return this.bell();
          }
          const newSelected = !this.value[this.cursor].selected;
          this.value.filter((v) => !v.disabled).forEach((v) => v.selected = newSelected);
          this.render();
        }
        _(c, key) {
          if (c === " ") {
            this.handleSpaceToggle();
          } else if (c === "a") {
            this.toggleAll();
          } else {
            return this.bell();
          }
        }
        renderInstructions() {
          if (this.instructions === void 0 || this.instructions) {
            if (typeof this.instructions === "string") {
              return this.instructions;
            }
            return `
Instructions:
    ${figures.arrowUp}/${figures.arrowDown}: Highlight option
    ${figures.arrowLeft}/${figures.arrowRight}/[space]: Toggle selection
` + (this.maxChoices === void 0 ? `    a: Toggle all
` : "") + `    enter/return: Complete answer`;
          }
          return "";
        }
        renderOption(cursor2, v, i, arrowIndicator) {
          const prefix = (v.selected ? color.green(figures.radioOn) : figures.radioOff) + " " + arrowIndicator + " ";
          let title, desc;
          if (v.disabled) {
            title = cursor2 === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
          } else {
            title = cursor2 === i ? color.cyan().underline(v.title) : v.title;
            if (cursor2 === i && v.description) {
              desc = ` - ${v.description}`;
              if (prefix.length + title.length + desc.length >= this.out.columns || v.description.split(/\r?\n/).length > 1) {
                desc = "\n" + wrap(v.description, { margin: prefix.length, width: this.out.columns });
              }
            }
          }
          return prefix + title + color.gray(desc || "");
        }
        paginateOptions(options) {
          if (options.length === 0) {
            return color.red("No matches for this query.");
          }
          let { startIndex, endIndex } = entriesToDisplay(this.cursor, options.length, this.optionsPerPage);
          let prefix, styledOptions = [];
          for (let i = startIndex; i < endIndex; i++) {
            if (i === startIndex && startIndex > 0) {
              prefix = figures.arrowUp;
            } else if (i === endIndex - 1 && endIndex < options.length) {
              prefix = figures.arrowDown;
            } else {
              prefix = " ";
            }
            styledOptions.push(this.renderOption(this.cursor, options[i], i, prefix));
          }
          return "\n" + styledOptions.join("\n");
        }
        renderOptions(options) {
          if (!this.done) {
            return this.paginateOptions(options);
          }
          return "";
        }
        renderDoneOrInstructions() {
          if (this.done) {
            return this.value.filter((e) => e.selected).map((v) => v.title).join(", ");
          }
          const output = [color.gray(this.hint), this.renderInstructions()];
          if (this.value[this.cursor].disabled) {
            output.push(color.yellow(this.warn));
          }
          return output.join(" ");
        }
        render() {
          if (this.closed)
            return;
          if (this.firstRender)
            this.out.write(cursor.hide);
          super.render();
          let prompt = [
            style.symbol(this.done, this.aborted),
            color.bold(this.msg),
            style.delimiter(false),
            this.renderDoneOrInstructions()
          ].join(" ");
          if (this.showMinError) {
            prompt += color.red(`You must select a minimum of ${this.minSelected} choices.`);
            this.showMinError = false;
          }
          prompt += this.renderOptions(this.value);
          this.out.write(this.clear + prompt);
          this.clear = clear(prompt, this.out.columns);
        }
      };
      module2.exports = MultiselectPrompt;
    });
    var require_autocomplete2 = __commonJS2((exports2, module2) => {
      "use strict";
      var color = require_kleur();
      var Prompt = require_prompt2();
      var { erase, cursor } = require_src();
      var { style, clear, figures, wrap, entriesToDisplay } = require_util2();
      var getVal = (arr, i) => arr[i] && (arr[i].value || arr[i].title || arr[i]);
      var getTitle = (arr, i) => arr[i] && (arr[i].title || arr[i].value || arr[i]);
      var getIndex = (arr, valOrTitle) => {
        const index = arr.findIndex((el) => el.value === valOrTitle || el.title === valOrTitle);
        return index > -1 ? index : void 0;
      };
      var AutocompletePrompt = class extends Prompt {
        constructor(opts = {}) {
          super(opts);
          this.msg = opts.message;
          this.suggest = opts.suggest;
          this.choices = opts.choices;
          this.initial = typeof opts.initial === "number" ? opts.initial : getIndex(opts.choices, opts.initial);
          this.select = this.initial || opts.cursor || 0;
          this.i18n = { noMatches: opts.noMatches || "no matches found" };
          this.fallback = opts.fallback || this.initial;
          this.clearFirst = opts.clearFirst || false;
          this.suggestions = [];
          this.input = "";
          this.limit = opts.limit || 10;
          this.cursor = 0;
          this.transform = style.render(opts.style);
          this.scale = this.transform.scale;
          this.render = this.render.bind(this);
          this.complete = this.complete.bind(this);
          this.clear = clear("", this.out.columns);
          this.complete(this.render);
          this.render();
        }
        set fallback(fb) {
          this._fb = Number.isSafeInteger(parseInt(fb)) ? parseInt(fb) : fb;
        }
        get fallback() {
          let choice;
          if (typeof this._fb === "number")
            choice = this.choices[this._fb];
          else if (typeof this._fb === "string")
            choice = { title: this._fb };
          return choice || this._fb || { title: this.i18n.noMatches };
        }
        moveSelect(i) {
          this.select = i;
          if (this.suggestions.length > 0)
            this.value = getVal(this.suggestions, i);
          else
            this.value = this.fallback.value;
          this.fire();
        }
        async complete(cb) {
          const p = this.completing = this.suggest(this.input, this.choices);
          const suggestions = await p;
          if (this.completing !== p)
            return;
          this.suggestions = suggestions.map((s, i, arr) => ({ title: getTitle(arr, i), value: getVal(arr, i), description: s.description }));
          this.completing = false;
          const l = Math.max(suggestions.length - 1, 0);
          this.moveSelect(Math.min(l, this.select));
          cb && cb();
        }
        reset() {
          this.input = "";
          this.complete(() => {
            this.moveSelect(this.initial !== void 0 ? this.initial : 0);
            this.render();
          });
          this.render();
        }
        exit() {
          if (this.clearFirst && this.input.length > 0) {
            this.reset();
          } else {
            this.done = this.exited = true;
            this.aborted = false;
            this.fire();
            this.render();
            this.out.write("\n");
            this.close();
          }
        }
        abort() {
          this.done = this.aborted = true;
          this.exited = false;
          this.fire();
          this.render();
          this.out.write("\n");
          this.close();
        }
        submit() {
          this.done = true;
          this.aborted = this.exited = false;
          this.fire();
          this.render();
          this.out.write("\n");
          this.close();
        }
        _(c, key) {
          let s1 = this.input.slice(0, this.cursor);
          let s2 = this.input.slice(this.cursor);
          this.input = `${s1}${c}${s2}`;
          this.cursor = s1.length + 1;
          this.complete(this.render);
          this.render();
        }
        delete() {
          if (this.cursor === 0)
            return this.bell();
          let s1 = this.input.slice(0, this.cursor - 1);
          let s2 = this.input.slice(this.cursor);
          this.input = `${s1}${s2}`;
          this.complete(this.render);
          this.cursor = this.cursor - 1;
          this.render();
        }
        deleteForward() {
          if (this.cursor * this.scale >= this.rendered.length)
            return this.bell();
          let s1 = this.input.slice(0, this.cursor);
          let s2 = this.input.slice(this.cursor + 1);
          this.input = `${s1}${s2}`;
          this.complete(this.render);
          this.render();
        }
        first() {
          this.moveSelect(0);
          this.render();
        }
        last() {
          this.moveSelect(this.suggestions.length - 1);
          this.render();
        }
        up() {
          if (this.select === 0) {
            this.moveSelect(this.suggestions.length - 1);
          } else {
            this.moveSelect(this.select - 1);
          }
          this.render();
        }
        down() {
          if (this.select === this.suggestions.length - 1) {
            this.moveSelect(0);
          } else {
            this.moveSelect(this.select + 1);
          }
          this.render();
        }
        next() {
          if (this.select === this.suggestions.length - 1) {
            this.moveSelect(0);
          } else
            this.moveSelect(this.select + 1);
          this.render();
        }
        nextPage() {
          this.moveSelect(Math.min(this.select + this.limit, this.suggestions.length - 1));
          this.render();
        }
        prevPage() {
          this.moveSelect(Math.max(this.select - this.limit, 0));
          this.render();
        }
        left() {
          if (this.cursor <= 0)
            return this.bell();
          this.cursor = this.cursor - 1;
          this.render();
        }
        right() {
          if (this.cursor * this.scale >= this.rendered.length)
            return this.bell();
          this.cursor = this.cursor + 1;
          this.render();
        }
        renderOption(v, hovered, isStart, isEnd) {
          let desc;
          let prefix = isStart ? figures.arrowUp : isEnd ? figures.arrowDown : " ";
          let title = hovered ? color.cyan().underline(v.title) : v.title;
          prefix = (hovered ? color.cyan(figures.pointer) + " " : "  ") + prefix;
          if (v.description) {
            desc = ` - ${v.description}`;
            if (prefix.length + title.length + desc.length >= this.out.columns || v.description.split(/\r?\n/).length > 1) {
              desc = "\n" + wrap(v.description, { margin: 3, width: this.out.columns });
            }
          }
          return prefix + " " + title + color.gray(desc || "");
        }
        render() {
          if (this.closed)
            return;
          if (this.firstRender)
            this.out.write(cursor.hide);
          else
            this.out.write(clear(this.outputText, this.out.columns));
          super.render();
          let { startIndex, endIndex } = entriesToDisplay(this.select, this.choices.length, this.limit);
          this.outputText = [
            style.symbol(this.done, this.aborted, this.exited),
            color.bold(this.msg),
            style.delimiter(this.completing),
            this.done && this.suggestions[this.select] ? this.suggestions[this.select].title : this.rendered = this.transform.render(this.input)
          ].join(" ");
          if (!this.done) {
            const suggestions = this.suggestions.slice(startIndex, endIndex).map((item, i) => this.renderOption(item, this.select === i + startIndex, i === 0 && startIndex > 0, i + startIndex === endIndex - 1 && endIndex < this.choices.length)).join("\n");
            this.outputText += `
` + (suggestions || color.gray(this.fallback.title));
          }
          this.out.write(erase.line + cursor.to(0) + this.outputText);
        }
      };
      module2.exports = AutocompletePrompt;
    });
    var require_autocompleteMultiselect2 = __commonJS2((exports2, module2) => {
      "use strict";
      var color = require_kleur();
      var { cursor } = require_src();
      var MultiselectPrompt = require_multiselect2();
      var { clear, style, figures } = require_util2();
      var AutocompleteMultiselectPrompt = class extends MultiselectPrompt {
        constructor(opts = {}) {
          opts.overrideRender = true;
          super(opts);
          this.inputValue = "";
          this.clear = clear("", this.out.columns);
          this.filteredOptions = this.value;
          this.render();
        }
        last() {
          this.cursor = this.filteredOptions.length - 1;
          this.render();
        }
        next() {
          this.cursor = (this.cursor + 1) % this.filteredOptions.length;
          this.render();
        }
        up() {
          if (this.cursor === 0) {
            this.cursor = this.filteredOptions.length - 1;
          } else {
            this.cursor--;
          }
          this.render();
        }
        down() {
          if (this.cursor === this.filteredOptions.length - 1) {
            this.cursor = 0;
          } else {
            this.cursor++;
          }
          this.render();
        }
        left() {
          this.filteredOptions[this.cursor].selected = false;
          this.render();
        }
        right() {
          if (this.value.filter((e) => e.selected).length >= this.maxChoices)
            return this.bell();
          this.filteredOptions[this.cursor].selected = true;
          this.render();
        }
        delete() {
          if (this.inputValue.length) {
            this.inputValue = this.inputValue.substr(0, this.inputValue.length - 1);
            this.updateFilteredOptions();
          }
        }
        updateFilteredOptions() {
          const currentHighlight = this.filteredOptions[this.cursor];
          this.filteredOptions = this.value.filter((v) => {
            if (this.inputValue) {
              if (typeof v.title === "string") {
                if (v.title.toLowerCase().includes(this.inputValue.toLowerCase())) {
                  return true;
                }
              }
              if (typeof v.value === "string") {
                if (v.value.toLowerCase().includes(this.inputValue.toLowerCase())) {
                  return true;
                }
              }
              return false;
            }
            return true;
          });
          const newHighlightIndex = this.filteredOptions.findIndex((v) => v === currentHighlight);
          this.cursor = newHighlightIndex < 0 ? 0 : newHighlightIndex;
          this.render();
        }
        handleSpaceToggle() {
          const v = this.filteredOptions[this.cursor];
          if (v.selected) {
            v.selected = false;
            this.render();
          } else if (v.disabled || this.value.filter((e) => e.selected).length >= this.maxChoices) {
            return this.bell();
          } else {
            v.selected = true;
            this.render();
          }
        }
        handleInputChange(c) {
          this.inputValue = this.inputValue + c;
          this.updateFilteredOptions();
        }
        _(c, key) {
          if (c === " ") {
            this.handleSpaceToggle();
          } else {
            this.handleInputChange(c);
          }
        }
        renderInstructions() {
          if (this.instructions === void 0 || this.instructions) {
            if (typeof this.instructions === "string") {
              return this.instructions;
            }
            return `
Instructions:
    ${figures.arrowUp}/${figures.arrowDown}: Highlight option
    ${figures.arrowLeft}/${figures.arrowRight}/[space]: Toggle selection
    [a,b,c]/delete: Filter choices
    enter/return: Complete answer
`;
          }
          return "";
        }
        renderCurrentInput() {
          return `
Filtered results for: ${this.inputValue ? this.inputValue : color.gray("Enter something to filter")}
`;
        }
        renderOption(cursor2, v, i) {
          let title;
          if (v.disabled)
            title = cursor2 === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
          else
            title = cursor2 === i ? color.cyan().underline(v.title) : v.title;
          return (v.selected ? color.green(figures.radioOn) : figures.radioOff) + "  " + title;
        }
        renderDoneOrInstructions() {
          if (this.done) {
            return this.value.filter((e) => e.selected).map((v) => v.title).join(", ");
          }
          const output = [color.gray(this.hint), this.renderInstructions(), this.renderCurrentInput()];
          if (this.filteredOptions.length && this.filteredOptions[this.cursor].disabled) {
            output.push(color.yellow(this.warn));
          }
          return output.join(" ");
        }
        render() {
          if (this.closed)
            return;
          if (this.firstRender)
            this.out.write(cursor.hide);
          super.render();
          let prompt = [
            style.symbol(this.done, this.aborted),
            color.bold(this.msg),
            style.delimiter(false),
            this.renderDoneOrInstructions()
          ].join(" ");
          if (this.showMinError) {
            prompt += color.red(`You must select a minimum of ${this.minSelected} choices.`);
            this.showMinError = false;
          }
          prompt += this.renderOptions(this.filteredOptions);
          this.out.write(this.clear + prompt);
          this.clear = clear(prompt, this.out.columns);
        }
      };
      module2.exports = AutocompleteMultiselectPrompt;
    });
    var require_confirm2 = __commonJS2((exports2, module2) => {
      var color = require_kleur();
      var Prompt = require_prompt2();
      var { style, clear } = require_util2();
      var { erase, cursor } = require_src();
      var ConfirmPrompt = class extends Prompt {
        constructor(opts = {}) {
          super(opts);
          this.msg = opts.message;
          this.value = opts.initial;
          this.initialValue = !!opts.initial;
          this.yesMsg = opts.yes || "yes";
          this.yesOption = opts.yesOption || "(Y/n)";
          this.noMsg = opts.no || "no";
          this.noOption = opts.noOption || "(y/N)";
          this.render();
        }
        reset() {
          this.value = this.initialValue;
          this.fire();
          this.render();
        }
        exit() {
          this.abort();
        }
        abort() {
          this.done = this.aborted = true;
          this.fire();
          this.render();
          this.out.write("\n");
          this.close();
        }
        submit() {
          this.value = this.value || false;
          this.done = true;
          this.aborted = false;
          this.fire();
          this.render();
          this.out.write("\n");
          this.close();
        }
        _(c, key) {
          if (c.toLowerCase() === "y") {
            this.value = true;
            return this.submit();
          }
          if (c.toLowerCase() === "n") {
            this.value = false;
            return this.submit();
          }
          return this.bell();
        }
        render() {
          if (this.closed)
            return;
          if (this.firstRender)
            this.out.write(cursor.hide);
          else
            this.out.write(clear(this.outputText, this.out.columns));
          super.render();
          this.outputText = [
            style.symbol(this.done, this.aborted),
            color.bold(this.msg),
            style.delimiter(this.done),
            this.done ? this.value ? this.yesMsg : this.noMsg : color.gray(this.initialValue ? this.yesOption : this.noOption)
          ].join(" ");
          this.out.write(erase.line + cursor.to(0) + this.outputText);
        }
      };
      module2.exports = ConfirmPrompt;
    });
    var require_elements2 = __commonJS2((exports2, module2) => {
      "use strict";
      module2.exports = {
        TextPrompt: require_text2(),
        SelectPrompt: require_select2(),
        TogglePrompt: require_toggle2(),
        DatePrompt: require_date2(),
        NumberPrompt: require_number2(),
        MultiselectPrompt: require_multiselect2(),
        AutocompletePrompt: require_autocomplete2(),
        AutocompleteMultiselectPrompt: require_autocompleteMultiselect2(),
        ConfirmPrompt: require_confirm2()
      };
    });
    var require_prompts2 = __commonJS2((exports2) => {
      "use strict";
      var $ = exports2;
      var el = require_elements2();
      var noop = (v) => v;
      function toPrompt(type, args, opts = {}) {
        return new Promise((res, rej) => {
          const p = new el[type](args);
          const onAbort = opts.onAbort || noop;
          const onSubmit = opts.onSubmit || noop;
          const onExit = opts.onExit || noop;
          p.on("state", args.onState || noop);
          p.on("submit", (x) => res(onSubmit(x)));
          p.on("exit", (x) => res(onExit(x)));
          p.on("abort", (x) => rej(onAbort(x)));
        });
      }
      $.text = (args) => toPrompt("TextPrompt", args);
      $.password = (args) => {
        args.style = "password";
        return $.text(args);
      };
      $.invisible = (args) => {
        args.style = "invisible";
        return $.text(args);
      };
      $.number = (args) => toPrompt("NumberPrompt", args);
      $.date = (args) => toPrompt("DatePrompt", args);
      $.confirm = (args) => toPrompt("ConfirmPrompt", args);
      $.list = (args) => {
        const sep = args.separator || ",";
        return toPrompt("TextPrompt", args, {
          onSubmit: (str) => str.split(sep).map((s) => s.trim())
        });
      };
      $.toggle = (args) => toPrompt("TogglePrompt", args);
      $.select = (args) => toPrompt("SelectPrompt", args);
      $.multiselect = (args) => {
        args.choices = [].concat(args.choices || []);
        const toSelected = (items) => items.filter((item) => item.selected).map((item) => item.value);
        return toPrompt("MultiselectPrompt", args, {
          onAbort: toSelected,
          onSubmit: toSelected
        });
      };
      $.autocompleteMultiselect = (args) => {
        args.choices = [].concat(args.choices || []);
        const toSelected = (items) => items.filter((item) => item.selected).map((item) => item.value);
        return toPrompt("AutocompleteMultiselectPrompt", args, {
          onAbort: toSelected,
          onSubmit: toSelected
        });
      };
      var byTitle = (input, choices) => Promise.resolve(choices.filter((item) => item.title.slice(0, input.length).toLowerCase() === input.toLowerCase()));
      $.autocomplete = (args) => {
        args.suggest = args.suggest || byTitle;
        args.choices = [].concat(args.choices || []);
        return toPrompt("AutocompletePrompt", args);
      };
    });
    var require_lib = __commonJS2((exports2, module2) => {
      "use strict";
      var prompts3 = require_prompts2();
      var passOn = ["suggest", "format", "onState", "validate", "onRender", "type"];
      var noop = () => {
      };
      async function prompt(questions = [], { onSubmit = noop, onCancel = noop } = {}) {
        const answers = {};
        const override2 = prompt._override || {};
        questions = [].concat(questions);
        let answer, question, quit, name, type, lastPrompt;
        const getFormattedAnswer = async (question2, answer2, skipValidation = false) => {
          if (!skipValidation && question2.validate && question2.validate(answer2) !== true) {
            return;
          }
          return question2.format ? await question2.format(answer2, answers) : answer2;
        };
        for (question of questions) {
          ({ name, type } = question);
          if (typeof type === "function") {
            type = await type(answer, __objSpread({}, answers), question);
            question["type"] = type;
          }
          if (!type)
            continue;
          for (let key in question) {
            if (passOn.includes(key))
              continue;
            let value = question[key];
            question[key] = typeof value === "function" ? await value(answer, __objSpread({}, answers), lastPrompt) : value;
          }
          lastPrompt = question;
          if (typeof question.message !== "string") {
            throw new Error("prompt message is required");
          }
          ({ name, type } = question);
          if (prompts3[type] === void 0) {
            throw new Error(`prompt type (${type}) is not defined`);
          }
          if (override2[question.name] !== void 0) {
            answer = await getFormattedAnswer(question, override2[question.name]);
            if (answer !== void 0) {
              answers[name] = answer;
              continue;
            }
          }
          try {
            answer = prompt._injected ? getInjectedAnswer(prompt._injected, question.initial) : await prompts3[type](question);
            answers[name] = answer = await getFormattedAnswer(question, answer, true);
            quit = await onSubmit(question, answer, answers);
          } catch (err) {
            quit = !await onCancel(question, answers);
          }
          if (quit)
            return answers;
        }
        return answers;
      }
      function getInjectedAnswer(injected, deafultValue) {
        const answer = injected.shift();
        if (answer instanceof Error) {
          throw answer;
        }
        return answer === void 0 ? deafultValue : answer;
      }
      function inject(answers) {
        prompt._injected = (prompt._injected || []).concat(answers);
      }
      function override(answers) {
        prompt._override = Object.assign({}, answers);
      }
      module2.exports = Object.assign(prompt, { prompt, prompts: prompts3, inject, override });
    });
    var require_prompts3 = __commonJS2((exports2, module2) => {
      function isNodeLT(tar) {
        tar = (Array.isArray(tar) ? tar : tar.split(".")).map(Number);
        let i = 0, src = process.versions.node.split(".").map(Number);
        for (; i < tar.length; i++) {
          if (src[i] > tar[i])
            return false;
          if (tar[i] > src[i])
            return true;
        }
        return false;
      }
      module2.exports = isNodeLT("8.6.0") ? require_dist2() : require_lib();
    });
    var require_ini = __commonJS2((exports2, module2) => {
      var { hasOwnProperty } = Object.prototype;
      var eol = typeof process !== "undefined" && process.platform === "win32" ? "\r\n" : "\n";
      var encode = (obj, opt) => {
        const children = [];
        let out = "";
        if (typeof opt === "string") {
          opt = {
            section: opt,
            whitespace: false
          };
        } else {
          opt = opt || Object.create(null);
          opt.whitespace = opt.whitespace === true;
        }
        const separator = opt.whitespace ? " = " : "=";
        for (const k of Object.keys(obj)) {
          const val = obj[k];
          if (val && Array.isArray(val)) {
            for (const item of val)
              out += safe(k + "[]") + separator + safe(item) + "\n";
          } else if (val && typeof val === "object")
            children.push(k);
          else
            out += safe(k) + separator + safe(val) + eol;
        }
        if (opt.section && out.length)
          out = "[" + safe(opt.section) + "]" + eol + out;
        for (const k of children) {
          const nk = dotSplit(k).join("\\.");
          const section = (opt.section ? opt.section + "." : "") + nk;
          const { whitespace } = opt;
          const child = encode(obj[k], {
            section,
            whitespace
          });
          if (out.length && child.length)
            out += eol;
          out += child;
        }
        return out;
      };
      var dotSplit = (str) => str.replace(/\1/g, "LITERAL\\1LITERAL").replace(/\\\./g, "").split(/\./).map((part) => part.replace(/\1/g, "\\.").replace(/\2LITERAL\\1LITERAL\2/g, ""));
      var decode = (str) => {
        const out = Object.create(null);
        let p = out;
        let section = null;
        const re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i;
        const lines = str.split(/[\r\n]+/g);
        for (const line of lines) {
          if (!line || line.match(/^\s*[;#]/))
            continue;
          const match = line.match(re);
          if (!match)
            continue;
          if (match[1] !== void 0) {
            section = unsafe(match[1]);
            if (section === "__proto__") {
              p = Object.create(null);
              continue;
            }
            p = out[section] = out[section] || Object.create(null);
            continue;
          }
          const keyRaw = unsafe(match[2]);
          const isArray = keyRaw.length > 2 && keyRaw.slice(-2) === "[]";
          const key = isArray ? keyRaw.slice(0, -2) : keyRaw;
          if (key === "__proto__")
            continue;
          const valueRaw = match[3] ? unsafe(match[4]) : true;
          const value = valueRaw === "true" || valueRaw === "false" || valueRaw === "null" ? JSON.parse(valueRaw) : valueRaw;
          if (isArray) {
            if (!hasOwnProperty.call(p, key))
              p[key] = [];
            else if (!Array.isArray(p[key]))
              p[key] = [p[key]];
          }
          if (Array.isArray(p[key]))
            p[key].push(value);
          else
            p[key] = value;
        }
        const remove2 = [];
        for (const k of Object.keys(out)) {
          if (!hasOwnProperty.call(out, k) || typeof out[k] !== "object" || Array.isArray(out[k]))
            continue;
          const parts = dotSplit(k);
          let p2 = out;
          const l = parts.pop();
          const nl = l.replace(/\\\./g, ".");
          for (const part of parts) {
            if (part === "__proto__")
              continue;
            if (!hasOwnProperty.call(p2, part) || typeof p2[part] !== "object")
              p2[part] = Object.create(null);
            p2 = p2[part];
          }
          if (p2 === out && nl === l)
            continue;
          p2[nl] = out[k];
          remove2.push(k);
        }
        for (const del of remove2)
          delete out[del];
        return out;
      };
      var isQuoted = (val) => val.charAt(0) === '"' && val.slice(-1) === '"' || val.charAt(0) === "'" && val.slice(-1) === "'";
      var safe = (val) => typeof val !== "string" || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && isQuoted(val) || val !== val.trim() ? JSON.stringify(val) : val.replace(/;/g, "\\;").replace(/#/g, "\\#");
      var unsafe = (val, doUnesc) => {
        val = (val || "").trim();
        if (isQuoted(val)) {
          if (val.charAt(0) === "'")
            val = val.substr(1, val.length - 2);
          try {
            val = JSON.parse(val);
          } catch (_) {
          }
        } else {
          let esc = false;
          let unesc = "";
          for (let i = 0, l = val.length; i < l; i++) {
            const c = val.charAt(i);
            if (esc) {
              if ("\\;#".indexOf(c) !== -1)
                unesc += c;
              else
                unesc += "\\" + c;
              esc = false;
            } else if (";#".indexOf(c) !== -1)
              break;
            else if (c === "\\")
              esc = true;
            else
              unesc += c;
          }
          if (esc)
            unesc += "\\";
          return unesc.trim();
        }
        return val;
      };
      module2.exports = {
        parse: decode,
        decode,
        stringify: encode,
        encode,
        safe,
        unsafe
      };
    });
    var require_windows = __commonJS2((exports2, module2) => {
      module2.exports = isexe;
      isexe.sync = sync;
      var fs2 = _chunkKRCSYS75js.__require.call(void 0, "fs");
      function checkPathExt(path3, options) {
        var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
        if (!pathext) {
          return true;
        }
        pathext = pathext.split(";");
        if (pathext.indexOf("") !== -1) {
          return true;
        }
        for (var i = 0; i < pathext.length; i++) {
          var p = pathext[i].toLowerCase();
          if (p && path3.substr(-p.length).toLowerCase() === p) {
            return true;
          }
        }
        return false;
      }
      function checkStat(stat, path3, options) {
        if (!stat.isSymbolicLink() && !stat.isFile()) {
          return false;
        }
        return checkPathExt(path3, options);
      }
      function isexe(path3, options, cb) {
        fs2.stat(path3, function(er, stat) {
          cb(er, er ? false : checkStat(stat, path3, options));
        });
      }
      function sync(path3, options) {
        return checkStat(fs2.statSync(path3), path3, options);
      }
    });
    var require_mode = __commonJS2((exports2, module2) => {
      module2.exports = isexe;
      isexe.sync = sync;
      var fs2 = _chunkKRCSYS75js.__require.call(void 0, "fs");
      function isexe(path3, options, cb) {
        fs2.stat(path3, function(er, stat) {
          cb(er, er ? false : checkStat(stat, options));
        });
      }
      function sync(path3, options) {
        return checkStat(fs2.statSync(path3), options);
      }
      function checkStat(stat, options) {
        return stat.isFile() && checkMode(stat, options);
      }
      function checkMode(stat, options) {
        var mod = stat.mode;
        var uid = stat.uid;
        var gid = stat.gid;
        var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
        var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
        var u = parseInt("100", 8);
        var g = parseInt("010", 8);
        var o = parseInt("001", 8);
        var ug = u | g;
        var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
        return ret;
      }
    });
    var require_isexe = __commonJS2((exports2, module2) => {
      var fs2 = _chunkKRCSYS75js.__require.call(void 0, "fs");
      var core;
      if (process.platform === "win32" || global.TESTING_WINDOWS) {
        core = require_windows();
      } else {
        core = require_mode();
      }
      module2.exports = isexe;
      isexe.sync = sync;
      function isexe(path3, options, cb) {
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (!cb) {
          if (typeof Promise !== "function") {
            throw new TypeError("callback not provided");
          }
          return new Promise(function(resolve2, reject) {
            isexe(path3, options || {}, function(er, is) {
              if (er) {
                reject(er);
              } else {
                resolve2(is);
              }
            });
          });
        }
        core(path3, options || {}, function(er, is) {
          if (er) {
            if (er.code === "EACCES" || options && options.ignoreErrors) {
              er = null;
              is = false;
            }
          }
          cb(er, is);
        });
      }
      function sync(path3, options) {
        try {
          return core.sync(path3, options || {});
        } catch (er) {
          if (options && options.ignoreErrors || er.code === "EACCES") {
            return false;
          } else {
            throw er;
          }
        }
      }
    });
    var require_which = __commonJS2((exports2, module2) => {
      var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
      var path3 = _chunkKRCSYS75js.__require.call(void 0, "path");
      var COLON = isWindows ? ";" : ":";
      var isexe = require_isexe();
      var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
      var getPathInfo = (cmd, opt) => {
        const colon = opt.colon || COLON;
        const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
          ...isWindows ? [process.cwd()] : [],
          ...(opt.path || process.env.PATH || "").split(colon)
        ];
        const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
        const pathExt = isWindows ? pathExtExe.split(colon) : [""];
        if (isWindows) {
          if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
            pathExt.unshift("");
        }
        return {
          pathEnv,
          pathExt,
          pathExtExe
        };
      };
      var which = (cmd, opt, cb) => {
        if (typeof opt === "function") {
          cb = opt;
          opt = {};
        }
        if (!opt)
          opt = {};
        const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
        const found = [];
        const step = (i) => new Promise((resolve2, reject) => {
          if (i === pathEnv.length)
            return opt.all && found.length ? resolve2(found) : reject(getNotFoundError(cmd));
          const ppRaw = pathEnv[i];
          const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
          const pCmd = path3.join(pathPart, cmd);
          const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
          resolve2(subStep(p, i, 0));
        });
        const subStep = (p, i, ii) => new Promise((resolve2, reject) => {
          if (ii === pathExt.length)
            return resolve2(step(i + 1));
          const ext = pathExt[ii];
          isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {
            if (!er && is) {
              if (opt.all)
                found.push(p + ext);
              else
                return resolve2(p + ext);
            }
            return resolve2(subStep(p, i, ii + 1));
          });
        });
        return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
      };
      var whichSync = (cmd, opt) => {
        opt = opt || {};
        const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
        const found = [];
        for (let i = 0; i < pathEnv.length; i++) {
          const ppRaw = pathEnv[i];
          const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
          const pCmd = path3.join(pathPart, cmd);
          const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
          for (let j = 0; j < pathExt.length; j++) {
            const cur = p + pathExt[j];
            try {
              const is = isexe.sync(cur, { pathExt: pathExtExe });
              if (is) {
                if (opt.all)
                  found.push(cur);
                else
                  return cur;
              }
            } catch (ex) {
            }
          }
        }
        if (opt.all && found.length)
          return found;
        if (opt.nothrow)
          return null;
        throw getNotFoundError(cmd);
      };
      module2.exports = which;
      which.sync = whichSync;
    });
    var require_path_key = __commonJS2((exports2, module2) => {
      "use strict";
      var pathKey = (options = {}) => {
        const environment = options.env || process.env;
        const platform = options.platform || process.platform;
        if (platform !== "win32") {
          return "PATH";
        }
        return Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
      };
      module2.exports = pathKey;
      module2.exports.default = pathKey;
    });
    var require_resolveCommand = __commonJS2((exports2, module2) => {
      "use strict";
      var path3 = _chunkKRCSYS75js.__require.call(void 0, "path");
      var which = require_which();
      var getPathKey = require_path_key();
      function resolveCommandAttempt(parsed, withoutPathExt) {
        const env = parsed.options.env || process.env;
        const cwd = process.cwd();
        const hasCustomCwd = parsed.options.cwd != null;
        const shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;
        if (shouldSwitchCwd) {
          try {
            process.chdir(parsed.options.cwd);
          } catch (err) {
          }
        }
        let resolved;
        try {
          resolved = which.sync(parsed.command, {
            path: env[getPathKey({ env })],
            pathExt: withoutPathExt ? path3.delimiter : void 0
          });
        } catch (e) {
        } finally {
          if (shouldSwitchCwd) {
            process.chdir(cwd);
          }
        }
        if (resolved) {
          resolved = path3.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
        }
        return resolved;
      }
      function resolveCommand(parsed) {
        return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
      }
      module2.exports = resolveCommand;
    });
    var require_escape = __commonJS2((exports2, module2) => {
      "use strict";
      var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
      function escapeCommand(arg) {
        arg = arg.replace(metaCharsRegExp, "^$1");
        return arg;
      }
      function escapeArgument(arg, doubleEscapeMetaChars) {
        arg = `${arg}`;
        arg = arg.replace(/(\\*)"/g, '$1$1\\"');
        arg = arg.replace(/(\\*)$/, "$1$1");
        arg = `"${arg}"`;
        arg = arg.replace(metaCharsRegExp, "^$1");
        if (doubleEscapeMetaChars) {
          arg = arg.replace(metaCharsRegExp, "^$1");
        }
        return arg;
      }
      module2.exports.command = escapeCommand;
      module2.exports.argument = escapeArgument;
    });
    var require_shebang_regex = __commonJS2((exports2, module2) => {
      "use strict";
      module2.exports = /^#!(.*)/;
    });
    var require_shebang_command = __commonJS2((exports2, module2) => {
      "use strict";
      var shebangRegex = require_shebang_regex();
      module2.exports = (string = "") => {
        const match = string.match(shebangRegex);
        if (!match) {
          return null;
        }
        const [path3, argument] = match[0].replace(/#! ?/, "").split(" ");
        const binary = path3.split("/").pop();
        if (binary === "env") {
          return argument;
        }
        return argument ? `${binary} ${argument}` : binary;
      };
    });
    var require_readShebang = __commonJS2((exports2, module2) => {
      "use strict";
      var fs2 = _chunkKRCSYS75js.__require.call(void 0, "fs");
      var shebangCommand = require_shebang_command();
      function readShebang(command) {
        const size = 150;
        const buffer = Buffer.alloc(size);
        let fd;
        try {
          fd = fs2.openSync(command, "r");
          fs2.readSync(fd, buffer, 0, size, 0);
          fs2.closeSync(fd);
        } catch (e) {
        }
        return shebangCommand(buffer.toString());
      }
      module2.exports = readShebang;
    });
    var require_parse2 = __commonJS2((exports2, module2) => {
      "use strict";
      var path3 = _chunkKRCSYS75js.__require.call(void 0, "path");
      var resolveCommand = require_resolveCommand();
      var escape = require_escape();
      var readShebang = require_readShebang();
      var isWin = process.platform === "win32";
      var isExecutableRegExp = /\.(?:com|exe)$/i;
      var isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
      function detectShebang(parsed) {
        parsed.file = resolveCommand(parsed);
        const shebang = parsed.file && readShebang(parsed.file);
        if (shebang) {
          parsed.args.unshift(parsed.file);
          parsed.command = shebang;
          return resolveCommand(parsed);
        }
        return parsed.file;
      }
      function parseNonShell(parsed) {
        if (!isWin) {
          return parsed;
        }
        const commandFile = detectShebang(parsed);
        const needsShell = !isExecutableRegExp.test(commandFile);
        if (parsed.options.forceShell || needsShell) {
          const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
          parsed.command = path3.normalize(parsed.command);
          parsed.command = escape.command(parsed.command);
          parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));
          const shellCommand = [parsed.command].concat(parsed.args).join(" ");
          parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
          parsed.command = process.env.comspec || "cmd.exe";
          parsed.options.windowsVerbatimArguments = true;
        }
        return parsed;
      }
      function parse(command, args, options) {
        if (args && !Array.isArray(args)) {
          options = args;
          args = null;
        }
        args = args ? args.slice(0) : [];
        options = Object.assign({}, options);
        const parsed = {
          command,
          args,
          options,
          file: void 0,
          original: {
            command,
            args
          }
        };
        return options.shell ? parsed : parseNonShell(parsed);
      }
      module2.exports = parse;
    });
    var require_enoent = __commonJS2((exports2, module2) => {
      "use strict";
      var isWin = process.platform === "win32";
      function notFoundError(original, syscall) {
        return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
          code: "ENOENT",
          errno: "ENOENT",
          syscall: `${syscall} ${original.command}`,
          path: original.command,
          spawnargs: original.args
        });
      }
      function hookChildProcess(cp, parsed) {
        if (!isWin) {
          return;
        }
        const originalEmit = cp.emit;
        cp.emit = function(name, arg1) {
          if (name === "exit") {
            const err = verifyENOENT(arg1, parsed, "spawn");
            if (err) {
              return originalEmit.call(cp, "error", err);
            }
          }
          return originalEmit.apply(cp, arguments);
        };
      }
      function verifyENOENT(status, parsed) {
        if (isWin && status === 1 && !parsed.file) {
          return notFoundError(parsed.original, "spawn");
        }
        return null;
      }
      function verifyENOENTSync(status, parsed) {
        if (isWin && status === 1 && !parsed.file) {
          return notFoundError(parsed.original, "spawnSync");
        }
        return null;
      }
      module2.exports = {
        hookChildProcess,
        verifyENOENT,
        verifyENOENTSync,
        notFoundError
      };
    });
    var require_cross_spawn = __commonJS2((exports2, module2) => {
      "use strict";
      var cp = _chunkKRCSYS75js.__require.call(void 0, "child_process");
      var parse = require_parse2();
      var enoent = require_enoent();
      function spawn(command, args, options) {
        const parsed = parse(command, args, options);
        const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
        enoent.hookChildProcess(spawned, parsed);
        return spawned;
      }
      function spawnSync(command, args, options) {
        const parsed = parse(command, args, options);
        const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
        result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
        return result;
      }
      module2.exports = spawn;
      module2.exports.spawn = spawn;
      module2.exports.sync = spawnSync;
      module2.exports._parse = parse;
      module2.exports._enoent = enoent;
    });
    var require_strip_final_newline = __commonJS2((exports2, module2) => {
      "use strict";
      module2.exports = (input) => {
        const LF = typeof input === "string" ? "\n" : "\n".charCodeAt();
        const CR = typeof input === "string" ? "\r" : "\r".charCodeAt();
        if (input[input.length - 1] === LF) {
          input = input.slice(0, input.length - 1);
        }
        if (input[input.length - 1] === CR) {
          input = input.slice(0, input.length - 1);
        }
        return input;
      };
    });
    var require_npm_run_path = __commonJS2((exports2, module2) => {
      "use strict";
      var path3 = _chunkKRCSYS75js.__require.call(void 0, "path");
      var pathKey = require_path_key();
      var npmRunPath = (options) => {
        options = __objSpread({
          cwd: process.cwd(),
          path: process.env[pathKey()],
          execPath: process.execPath
        }, options);
        let previous;
        let cwdPath = path3.resolve(options.cwd);
        const result = [];
        while (previous !== cwdPath) {
          result.push(path3.join(cwdPath, "node_modules/.bin"));
          previous = cwdPath;
          cwdPath = path3.resolve(cwdPath, "..");
        }
        const execPathDir = path3.resolve(options.cwd, options.execPath, "..");
        result.push(execPathDir);
        return result.concat(options.path).join(path3.delimiter);
      };
      module2.exports = npmRunPath;
      module2.exports.default = npmRunPath;
      module2.exports.env = (options) => {
        options = __objSpread({
          env: process.env
        }, options);
        const env = __objSpread({}, options.env);
        const path4 = pathKey({ env });
        options.path = env[path4];
        env[path4] = module2.exports(options);
        return env;
      };
    });
    var require_mimic_fn = __commonJS2((exports2, module2) => {
      "use strict";
      var mimicFn = (to, from) => {
        for (const prop of Reflect.ownKeys(from)) {
          Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
        }
        return to;
      };
      module2.exports = mimicFn;
      module2.exports.default = mimicFn;
    });
    var require_onetime = __commonJS2((exports2, module2) => {
      "use strict";
      var mimicFn = require_mimic_fn();
      var calledFunctions = new WeakMap();
      var onetime = (function_, options = {}) => {
        if (typeof function_ !== "function") {
          throw new TypeError("Expected a function");
        }
        let returnValue;
        let callCount = 0;
        const functionName = function_.displayName || function_.name || "<anonymous>";
        const onetime2 = function(...arguments_) {
          calledFunctions.set(onetime2, ++callCount);
          if (callCount === 1) {
            returnValue = function_.apply(this, arguments_);
            function_ = null;
          } else if (options.throw === true) {
            throw new Error(`Function \`${functionName}\` can only be called once`);
          }
          return returnValue;
        };
        mimicFn(onetime2, function_);
        calledFunctions.set(onetime2, callCount);
        return onetime2;
      };
      module2.exports = onetime;
      module2.exports.default = onetime;
      module2.exports.callCount = (function_) => {
        if (!calledFunctions.has(function_)) {
          throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
        }
        return calledFunctions.get(function_);
      };
    });
    var require_core = __commonJS2((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SIGNALS = void 0;
      var SIGNALS = [
        {
          name: "SIGHUP",
          number: 1,
          action: "terminate",
          description: "Terminal closed",
          standard: "posix"
        },
        {
          name: "SIGINT",
          number: 2,
          action: "terminate",
          description: "User interruption with CTRL-C",
          standard: "ansi"
        },
        {
          name: "SIGQUIT",
          number: 3,
          action: "core",
          description: "User interruption with CTRL-\\",
          standard: "posix"
        },
        {
          name: "SIGILL",
          number: 4,
          action: "core",
          description: "Invalid machine instruction",
          standard: "ansi"
        },
        {
          name: "SIGTRAP",
          number: 5,
          action: "core",
          description: "Debugger breakpoint",
          standard: "posix"
        },
        {
          name: "SIGABRT",
          number: 6,
          action: "core",
          description: "Aborted",
          standard: "ansi"
        },
        {
          name: "SIGIOT",
          number: 6,
          action: "core",
          description: "Aborted",
          standard: "bsd"
        },
        {
          name: "SIGBUS",
          number: 7,
          action: "core",
          description: "Bus error due to misaligned, non-existing address or paging error",
          standard: "bsd"
        },
        {
          name: "SIGEMT",
          number: 7,
          action: "terminate",
          description: "Command should be emulated but is not implemented",
          standard: "other"
        },
        {
          name: "SIGFPE",
          number: 8,
          action: "core",
          description: "Floating point arithmetic error",
          standard: "ansi"
        },
        {
          name: "SIGKILL",
          number: 9,
          action: "terminate",
          description: "Forced termination",
          standard: "posix",
          forced: true
        },
        {
          name: "SIGUSR1",
          number: 10,
          action: "terminate",
          description: "Application-specific signal",
          standard: "posix"
        },
        {
          name: "SIGSEGV",
          number: 11,
          action: "core",
          description: "Segmentation fault",
          standard: "ansi"
        },
        {
          name: "SIGUSR2",
          number: 12,
          action: "terminate",
          description: "Application-specific signal",
          standard: "posix"
        },
        {
          name: "SIGPIPE",
          number: 13,
          action: "terminate",
          description: "Broken pipe or socket",
          standard: "posix"
        },
        {
          name: "SIGALRM",
          number: 14,
          action: "terminate",
          description: "Timeout or timer",
          standard: "posix"
        },
        {
          name: "SIGTERM",
          number: 15,
          action: "terminate",
          description: "Termination",
          standard: "ansi"
        },
        {
          name: "SIGSTKFLT",
          number: 16,
          action: "terminate",
          description: "Stack is empty or overflowed",
          standard: "other"
        },
        {
          name: "SIGCHLD",
          number: 17,
          action: "ignore",
          description: "Child process terminated, paused or unpaused",
          standard: "posix"
        },
        {
          name: "SIGCLD",
          number: 17,
          action: "ignore",
          description: "Child process terminated, paused or unpaused",
          standard: "other"
        },
        {
          name: "SIGCONT",
          number: 18,
          action: "unpause",
          description: "Unpaused",
          standard: "posix",
          forced: true
        },
        {
          name: "SIGSTOP",
          number: 19,
          action: "pause",
          description: "Paused",
          standard: "posix",
          forced: true
        },
        {
          name: "SIGTSTP",
          number: 20,
          action: "pause",
          description: 'Paused using CTRL-Z or "suspend"',
          standard: "posix"
        },
        {
          name: "SIGTTIN",
          number: 21,
          action: "pause",
          description: "Background process cannot read terminal input",
          standard: "posix"
        },
        {
          name: "SIGBREAK",
          number: 21,
          action: "terminate",
          description: "User interruption with CTRL-BREAK",
          standard: "other"
        },
        {
          name: "SIGTTOU",
          number: 22,
          action: "pause",
          description: "Background process cannot write to terminal output",
          standard: "posix"
        },
        {
          name: "SIGURG",
          number: 23,
          action: "ignore",
          description: "Socket received out-of-band data",
          standard: "bsd"
        },
        {
          name: "SIGXCPU",
          number: 24,
          action: "core",
          description: "Process timed out",
          standard: "bsd"
        },
        {
          name: "SIGXFSZ",
          number: 25,
          action: "core",
          description: "File too big",
          standard: "bsd"
        },
        {
          name: "SIGVTALRM",
          number: 26,
          action: "terminate",
          description: "Timeout or timer",
          standard: "bsd"
        },
        {
          name: "SIGPROF",
          number: 27,
          action: "terminate",
          description: "Timeout or timer",
          standard: "bsd"
        },
        {
          name: "SIGWINCH",
          number: 28,
          action: "ignore",
          description: "Terminal window size changed",
          standard: "bsd"
        },
        {
          name: "SIGIO",
          number: 29,
          action: "terminate",
          description: "I/O is available",
          standard: "other"
        },
        {
          name: "SIGPOLL",
          number: 29,
          action: "terminate",
          description: "Watched event",
          standard: "other"
        },
        {
          name: "SIGINFO",
          number: 29,
          action: "ignore",
          description: "Request for process information",
          standard: "other"
        },
        {
          name: "SIGPWR",
          number: 30,
          action: "terminate",
          description: "Device running out of power",
          standard: "systemv"
        },
        {
          name: "SIGSYS",
          number: 31,
          action: "core",
          description: "Invalid system call",
          standard: "other"
        },
        {
          name: "SIGUNUSED",
          number: 31,
          action: "terminate",
          description: "Invalid system call",
          standard: "other"
        }
      ];
      exports2.SIGNALS = SIGNALS;
    });
    var require_realtime = __commonJS2((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SIGRTMAX = exports2.getRealtimeSignals = void 0;
      var getRealtimeSignals = function() {
        const length = SIGRTMAX - SIGRTMIN + 1;
        return Array.from({ length }, getRealtimeSignal);
      };
      exports2.getRealtimeSignals = getRealtimeSignals;
      var getRealtimeSignal = function(value, index) {
        return {
          name: `SIGRT${index + 1}`,
          number: SIGRTMIN + index,
          action: "terminate",
          description: "Application-specific signal (realtime)",
          standard: "posix"
        };
      };
      var SIGRTMIN = 34;
      var SIGRTMAX = 64;
      exports2.SIGRTMAX = SIGRTMAX;
    });
    var require_signals = __commonJS2((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getSignals = void 0;
      var _os = _chunkKRCSYS75js.__require.call(void 0, "os");
      var _core = require_core();
      var _realtime = require_realtime();
      var getSignals = function() {
        const realtimeSignals = (0, _realtime.getRealtimeSignals)();
        const signals = [..._core.SIGNALS, ...realtimeSignals].map(normalizeSignal);
        return signals;
      };
      exports2.getSignals = getSignals;
      var normalizeSignal = function({
        name,
        number: defaultNumber,
        description,
        action,
        forced = false,
        standard
      }) {
        const {
          signals: { [name]: constantSignal }
        } = _os.constants;
        const supported = constantSignal !== void 0;
        const number = supported ? constantSignal : defaultNumber;
        return { name, number, description, supported, action, forced, standard };
      };
    });
    var require_main = __commonJS2((exports2) => {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.signalsByNumber = exports2.signalsByName = void 0;
      var _os = _chunkKRCSYS75js.__require.call(void 0, "os");
      var _signals = require_signals();
      var _realtime = require_realtime();
      var getSignalsByName = function() {
        const signals = (0, _signals.getSignals)();
        return signals.reduce(getSignalByName, {});
      };
      var getSignalByName = function(signalByNameMemo, { name, number, description, supported, action, forced, standard }) {
        return __objSpread(__objSpread({}, signalByNameMemo), {
          [name]: { name, number, description, supported, action, forced, standard }
        });
      };
      var signalsByName = getSignalsByName();
      exports2.signalsByName = signalsByName;
      var getSignalsByNumber = function() {
        const signals = (0, _signals.getSignals)();
        const length = _realtime.SIGRTMAX + 1;
        const signalsA = Array.from({ length }, (value, number) => getSignalByNumber(number, signals));
        return Object.assign({}, ...signalsA);
      };
      var getSignalByNumber = function(number, signals) {
        const signal = findSignalByNumber(number, signals);
        if (signal === void 0) {
          return {};
        }
        const { name, description, supported, action, forced, standard } = signal;
        return {
          [number]: {
            name,
            number,
            description,
            supported,
            action,
            forced,
            standard
          }
        };
      };
      var findSignalByNumber = function(number, signals) {
        const signal = signals.find(({ name }) => _os.constants.signals[name] === number);
        if (signal !== void 0) {
          return signal;
        }
        return signals.find((signalA) => signalA.number === number);
      };
      var signalsByNumber = getSignalsByNumber();
      exports2.signalsByNumber = signalsByNumber;
    });
    var require_error = __commonJS2((exports2, module2) => {
      "use strict";
      var { signalsByName } = require_main();
      var getErrorPrefix = ({ timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled }) => {
        if (timedOut) {
          return `timed out after ${timeout} milliseconds`;
        }
        if (isCanceled) {
          return "was canceled";
        }
        if (errorCode !== void 0) {
          return `failed with ${errorCode}`;
        }
        if (signal !== void 0) {
          return `was killed with ${signal} (${signalDescription})`;
        }
        if (exitCode !== void 0) {
          return `failed with exit code ${exitCode}`;
        }
        return "failed";
      };
      var makeError = ({
        stdout,
        stderr,
        all,
        error,
        signal,
        exitCode,
        command,
        timedOut,
        isCanceled,
        killed,
        parsed: { options: { timeout } }
      }) => {
        exitCode = exitCode === null ? void 0 : exitCode;
        signal = signal === null ? void 0 : signal;
        const signalDescription = signal === void 0 ? void 0 : signalsByName[signal].description;
        const errorCode = error && error.code;
        const prefix = getErrorPrefix({ timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled });
        const execaMessage = `Command ${prefix}: ${command}`;
        const isError = Object.prototype.toString.call(error) === "[object Error]";
        const shortMessage = isError ? `${execaMessage}
${error.message}` : execaMessage;
        const message = [shortMessage, stderr, stdout].filter(Boolean).join("\n");
        if (isError) {
          error.originalMessage = error.message;
          error.message = message;
        } else {
          error = new Error(message);
        }
        error.shortMessage = shortMessage;
        error.command = command;
        error.exitCode = exitCode;
        error.signal = signal;
        error.signalDescription = signalDescription;
        error.stdout = stdout;
        error.stderr = stderr;
        if (all !== void 0) {
          error.all = all;
        }
        if ("bufferedData" in error) {
          delete error.bufferedData;
        }
        error.failed = true;
        error.timedOut = Boolean(timedOut);
        error.isCanceled = isCanceled;
        error.killed = killed && !timedOut;
        return error;
      };
      module2.exports = makeError;
    });
    var require_stdio = __commonJS2((exports2, module2) => {
      "use strict";
      var aliases = ["stdin", "stdout", "stderr"];
      var hasAlias = (options) => aliases.some((alias) => options[alias] !== void 0);
      var normalizeStdio = (options) => {
        if (!options) {
          return;
        }
        const { stdio } = options;
        if (stdio === void 0) {
          return aliases.map((alias) => options[alias]);
        }
        if (hasAlias(options)) {
          throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${aliases.map((alias) => `\`${alias}\``).join(", ")}`);
        }
        if (typeof stdio === "string") {
          return stdio;
        }
        if (!Array.isArray(stdio)) {
          throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
        }
        const length = Math.max(stdio.length, aliases.length);
        return Array.from({ length }, (value, index) => stdio[index]);
      };
      module2.exports = normalizeStdio;
      module2.exports.node = (options) => {
        const stdio = normalizeStdio(options);
        if (stdio === "ipc") {
          return "ipc";
        }
        if (stdio === void 0 || typeof stdio === "string") {
          return [stdio, stdio, stdio, "ipc"];
        }
        if (stdio.includes("ipc")) {
          return stdio;
        }
        return [...stdio, "ipc"];
      };
    });
    var require_signals2 = __commonJS2((exports2, module2) => {
      module2.exports = [
        "SIGABRT",
        "SIGALRM",
        "SIGHUP",
        "SIGINT",
        "SIGTERM"
      ];
      if (process.platform !== "win32") {
        module2.exports.push("SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
      }
      if (process.platform === "linux") {
        module2.exports.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT", "SIGUNUSED");
      }
    });
    var require_signal_exit = __commonJS2((exports2, module2) => {
      var assert = _chunkKRCSYS75js.__require.call(void 0, "assert");
      var signals = require_signals2();
      var isWin = /^win/i.test(process.platform);
      var EE = _chunkKRCSYS75js.__require.call(void 0, "events");
      if (typeof EE !== "function") {
        EE = EE.EventEmitter;
      }
      var emitter;
      if (process.__signal_exit_emitter__) {
        emitter = process.__signal_exit_emitter__;
      } else {
        emitter = process.__signal_exit_emitter__ = new EE();
        emitter.count = 0;
        emitter.emitted = {};
      }
      if (!emitter.infinite) {
        emitter.setMaxListeners(Infinity);
        emitter.infinite = true;
      }
      module2.exports = function(cb, opts) {
        assert.equal(typeof cb, "function", "a callback must be provided for exit handler");
        if (loaded === false) {
          load2();
        }
        var ev = "exit";
        if (opts && opts.alwaysLast) {
          ev = "afterexit";
        }
        var remove2 = function() {
          emitter.removeListener(ev, cb);
          if (emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0) {
            unload();
          }
        };
        emitter.on(ev, cb);
        return remove2;
      };
      module2.exports.unload = unload;
      function unload() {
        if (!loaded) {
          return;
        }
        loaded = false;
        signals.forEach(function(sig) {
          try {
            process.removeListener(sig, sigListeners[sig]);
          } catch (er) {
          }
        });
        process.emit = originalProcessEmit;
        process.reallyExit = originalProcessReallyExit;
        emitter.count -= 1;
      }
      function emit(event, code, signal) {
        if (emitter.emitted[event]) {
          return;
        }
        emitter.emitted[event] = true;
        emitter.emit(event, code, signal);
      }
      var sigListeners = {};
      signals.forEach(function(sig) {
        sigListeners[sig] = function listener() {
          var listeners = process.listeners(sig);
          if (listeners.length === emitter.count) {
            unload();
            emit("exit", null, sig);
            emit("afterexit", null, sig);
            if (isWin && sig === "SIGHUP") {
              sig = "SIGINT";
            }
            process.kill(process.pid, sig);
          }
        };
      });
      module2.exports.signals = function() {
        return signals;
      };
      module2.exports.load = load2;
      var loaded = false;
      function load2() {
        if (loaded) {
          return;
        }
        loaded = true;
        emitter.count += 1;
        signals = signals.filter(function(sig) {
          try {
            process.on(sig, sigListeners[sig]);
            return true;
          } catch (er) {
            return false;
          }
        });
        process.emit = processEmit;
        process.reallyExit = processReallyExit;
      }
      var originalProcessReallyExit = process.reallyExit;
      function processReallyExit(code) {
        process.exitCode = code || 0;
        emit("exit", process.exitCode, null);
        emit("afterexit", process.exitCode, null);
        originalProcessReallyExit.call(process, process.exitCode);
      }
      var originalProcessEmit = process.emit;
      function processEmit(ev, arg) {
        if (ev === "exit") {
          if (arg !== void 0) {
            process.exitCode = arg;
          }
          var ret = originalProcessEmit.apply(this, arguments);
          emit("exit", process.exitCode, null);
          emit("afterexit", process.exitCode, null);
          return ret;
        } else {
          return originalProcessEmit.apply(this, arguments);
        }
      }
    });
    var require_kill = __commonJS2((exports2, module2) => {
      "use strict";
      var os2 = _chunkKRCSYS75js.__require.call(void 0, "os");
      var onExit = require_signal_exit();
      var DEFAULT_FORCE_KILL_TIMEOUT = 1e3 * 5;
      var spawnedKill = (kill, signal = "SIGTERM", options = {}) => {
        const killResult = kill(signal);
        setKillTimeout(kill, signal, options, killResult);
        return killResult;
      };
      var setKillTimeout = (kill, signal, options, killResult) => {
        if (!shouldForceKill(signal, options, killResult)) {
          return;
        }
        const timeout = getForceKillAfterTimeout(options);
        const t = setTimeout(() => {
          kill("SIGKILL");
        }, timeout);
        if (t.unref) {
          t.unref();
        }
      };
      var shouldForceKill = (signal, { forceKillAfterTimeout }, killResult) => {
        return isSigterm(signal) && forceKillAfterTimeout !== false && killResult;
      };
      var isSigterm = (signal) => {
        return signal === os2.constants.signals.SIGTERM || typeof signal === "string" && signal.toUpperCase() === "SIGTERM";
      };
      var getForceKillAfterTimeout = ({ forceKillAfterTimeout = true }) => {
        if (forceKillAfterTimeout === true) {
          return DEFAULT_FORCE_KILL_TIMEOUT;
        }
        if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {
          throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${forceKillAfterTimeout}\` (${typeof forceKillAfterTimeout})`);
        }
        return forceKillAfterTimeout;
      };
      var spawnedCancel = (spawned, context) => {
        const killResult = spawned.kill();
        if (killResult) {
          context.isCanceled = true;
        }
      };
      var timeoutKill = (spawned, signal, reject) => {
        spawned.kill(signal);
        reject(Object.assign(new Error("Timed out"), { timedOut: true, signal }));
      };
      var setupTimeout = (spawned, { timeout, killSignal = "SIGTERM" }, spawnedPromise) => {
        if (timeout === 0 || timeout === void 0) {
          return spawnedPromise;
        }
        if (!Number.isFinite(timeout) || timeout < 0) {
          throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
        }
        let timeoutId;
        const timeoutPromise = new Promise((resolve2, reject) => {
          timeoutId = setTimeout(() => {
            timeoutKill(spawned, killSignal, reject);
          }, timeout);
        });
        const safeSpawnedPromise = spawnedPromise.finally(() => {
          clearTimeout(timeoutId);
        });
        return Promise.race([timeoutPromise, safeSpawnedPromise]);
      };
      var setExitHandler = async (spawned, { cleanup, detached }, timedPromise) => {
        if (!cleanup || detached) {
          return timedPromise;
        }
        const removeExitHandler = onExit(() => {
          spawned.kill();
        });
        return timedPromise.finally(() => {
          removeExitHandler();
        });
      };
      module2.exports = {
        spawnedKill,
        spawnedCancel,
        setupTimeout,
        setExitHandler
      };
    });
    var require_is_stream = __commonJS2((exports2, module2) => {
      "use strict";
      var isStream = (stream) => stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
      isStream.writable = (stream) => isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
      isStream.readable = (stream) => isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
      isStream.duplex = (stream) => isStream.writable(stream) && isStream.readable(stream);
      isStream.transform = (stream) => isStream.duplex(stream) && typeof stream._transform === "function" && typeof stream._transformState === "object";
      module2.exports = isStream;
    });
    var require_buffer_stream = __commonJS2((exports2, module2) => {
      "use strict";
      var { PassThrough: PassThroughStream } = _chunkKRCSYS75js.__require.call(void 0, "stream");
      module2.exports = (options) => {
        options = __objSpread({}, options);
        const { array } = options;
        let { encoding } = options;
        const isBuffer = encoding === "buffer";
        let objectMode = false;
        if (array) {
          objectMode = !(encoding || isBuffer);
        } else {
          encoding = encoding || "utf8";
        }
        if (isBuffer) {
          encoding = null;
        }
        const stream = new PassThroughStream({ objectMode });
        if (encoding) {
          stream.setEncoding(encoding);
        }
        let length = 0;
        const chunks = [];
        stream.on("data", (chunk) => {
          chunks.push(chunk);
          if (objectMode) {
            length = chunks.length;
          } else {
            length += chunk.length;
          }
        });
        stream.getBufferedValue = () => {
          if (array) {
            return chunks;
          }
          return isBuffer ? Buffer.concat(chunks, length) : chunks.join("");
        };
        stream.getBufferedLength = () => length;
        return stream;
      };
    });
    var require_get_stream = __commonJS2((exports2, module2) => {
      "use strict";
      var { constants: BufferConstants } = _chunkKRCSYS75js.__require.call(void 0, "buffer");
      var stream = _chunkKRCSYS75js.__require.call(void 0, "stream");
      var { promisify } = _chunkKRCSYS75js.__require.call(void 0, "util");
      var bufferStream = require_buffer_stream();
      var streamPipelinePromisified = promisify(stream.pipeline);
      var MaxBufferError = class extends Error {
        constructor() {
          super("maxBuffer exceeded");
          this.name = "MaxBufferError";
        }
      };
      async function getStream(inputStream, options) {
        if (!inputStream) {
          throw new Error("Expected a stream");
        }
        options = __objSpread({
          maxBuffer: Infinity
        }, options);
        const { maxBuffer } = options;
        const stream2 = bufferStream(options);
        await new Promise((resolve2, reject) => {
          const rejectPromise = (error) => {
            if (error && stream2.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
              error.bufferedData = stream2.getBufferedValue();
            }
            reject(error);
          };
          (async () => {
            try {
              await streamPipelinePromisified(inputStream, stream2);
              resolve2();
            } catch (error) {
              rejectPromise(error);
            }
          })();
          stream2.on("data", () => {
            if (stream2.getBufferedLength() > maxBuffer) {
              rejectPromise(new MaxBufferError());
            }
          });
        });
        return stream2.getBufferedValue();
      }
      module2.exports = getStream;
      module2.exports.buffer = (stream2, options) => getStream(stream2, __objSpread(__objSpread({}, options), { encoding: "buffer" }));
      module2.exports.array = (stream2, options) => getStream(stream2, __objSpread(__objSpread({}, options), { array: true }));
      module2.exports.MaxBufferError = MaxBufferError;
    });
    var require_merge_stream = __commonJS2((exports2, module2) => {
      "use strict";
      var { PassThrough } = _chunkKRCSYS75js.__require.call(void 0, "stream");
      module2.exports = function() {
        var sources = [];
        var output = new PassThrough({ objectMode: true });
        output.setMaxListeners(0);
        output.add = add;
        output.isEmpty = isEmpty;
        output.on("unpipe", remove2);
        Array.prototype.slice.call(arguments).forEach(add);
        return output;
        function add(source) {
          if (Array.isArray(source)) {
            source.forEach(add);
            return this;
          }
          sources.push(source);
          source.once("end", remove2.bind(null, source));
          source.once("error", output.emit.bind(output, "error"));
          source.pipe(output, { end: false });
          return this;
        }
        function isEmpty() {
          return sources.length == 0;
        }
        function remove2(source) {
          sources = sources.filter(function(it) {
            return it !== source;
          });
          if (!sources.length && output.readable) {
            output.end();
          }
        }
      };
    });
    var require_stream = __commonJS2((exports2, module2) => {
      "use strict";
      var isStream = require_is_stream();
      var getStream = require_get_stream();
      var mergeStream = require_merge_stream();
      var handleInput = (spawned, input) => {
        if (input === void 0 || spawned.stdin === void 0) {
          return;
        }
        if (isStream(input)) {
          input.pipe(spawned.stdin);
        } else {
          spawned.stdin.end(input);
        }
      };
      var makeAllStream = (spawned, { all }) => {
        if (!all || !spawned.stdout && !spawned.stderr) {
          return;
        }
        const mixed = mergeStream();
        if (spawned.stdout) {
          mixed.add(spawned.stdout);
        }
        if (spawned.stderr) {
          mixed.add(spawned.stderr);
        }
        return mixed;
      };
      var getBufferedData = async (stream, streamPromise) => {
        if (!stream) {
          return;
        }
        stream.destroy();
        try {
          return await streamPromise;
        } catch (error) {
          return error.bufferedData;
        }
      };
      var getStreamPromise = (stream, { encoding, buffer, maxBuffer }) => {
        if (!stream || !buffer) {
          return;
        }
        if (encoding) {
          return getStream(stream, { encoding, maxBuffer });
        }
        return getStream.buffer(stream, { maxBuffer });
      };
      var getSpawnedResult = async ({ stdout, stderr, all }, { encoding, buffer, maxBuffer }, processDone) => {
        const stdoutPromise = getStreamPromise(stdout, { encoding, buffer, maxBuffer });
        const stderrPromise = getStreamPromise(stderr, { encoding, buffer, maxBuffer });
        const allPromise = getStreamPromise(all, { encoding, buffer, maxBuffer: maxBuffer * 2 });
        try {
          return await Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);
        } catch (error) {
          return Promise.all([
            { error, signal: error.signal, timedOut: error.timedOut },
            getBufferedData(stdout, stdoutPromise),
            getBufferedData(stderr, stderrPromise),
            getBufferedData(all, allPromise)
          ]);
        }
      };
      var validateInputSync = ({ input }) => {
        if (isStream(input)) {
          throw new TypeError("The `input` option cannot be a stream in sync mode");
        }
      };
      module2.exports = {
        handleInput,
        makeAllStream,
        getSpawnedResult,
        validateInputSync
      };
    });
    var require_promise = __commonJS2((exports2, module2) => {
      "use strict";
      var nativePromisePrototype = (async () => {
      })().constructor.prototype;
      var descriptors = ["then", "catch", "finally"].map((property) => [
        property,
        Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)
      ]);
      var mergePromise = (spawned, promise) => {
        for (const [property, descriptor] of descriptors) {
          const value = typeof promise === "function" ? (...args) => Reflect.apply(descriptor.value, promise(), args) : descriptor.value.bind(promise);
          Reflect.defineProperty(spawned, property, __objSpread(__objSpread({}, descriptor), { value }));
        }
        return spawned;
      };
      var getSpawnedPromise = (spawned) => {
        return new Promise((resolve2, reject) => {
          spawned.on("exit", (exitCode, signal) => {
            resolve2({ exitCode, signal });
          });
          spawned.on("error", (error) => {
            reject(error);
          });
          if (spawned.stdin) {
            spawned.stdin.on("error", (error) => {
              reject(error);
            });
          }
        });
      };
      module2.exports = {
        mergePromise,
        getSpawnedPromise
      };
    });
    var require_command = __commonJS2((exports2, module2) => {
      "use strict";
      var SPACES_REGEXP = / +/g;
      var joinCommand = (file, args = []) => {
        if (!Array.isArray(args)) {
          return file;
        }
        return [file, ...args].join(" ");
      };
      var parseCommand = (command) => {
        const tokens = [];
        for (const token of command.trim().split(SPACES_REGEXP)) {
          const previousToken = tokens[tokens.length - 1];
          if (previousToken && previousToken.endsWith("\\")) {
            tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;
          } else {
            tokens.push(token);
          }
        }
        return tokens;
      };
      module2.exports = {
        joinCommand,
        parseCommand
      };
    });
    var require_execa = __commonJS2((exports2, module2) => {
      "use strict";
      var path3 = _chunkKRCSYS75js.__require.call(void 0, "path");
      var childProcess = _chunkKRCSYS75js.__require.call(void 0, "child_process");
      var crossSpawn = require_cross_spawn();
      var stripFinalNewline = require_strip_final_newline();
      var npmRunPath = require_npm_run_path();
      var onetime = require_onetime();
      var makeError = require_error();
      var normalizeStdio = require_stdio();
      var { spawnedKill, spawnedCancel, setupTimeout, setExitHandler } = require_kill();
      var { handleInput, getSpawnedResult, makeAllStream, validateInputSync } = require_stream();
      var { mergePromise, getSpawnedPromise } = require_promise();
      var { joinCommand, parseCommand } = require_command();
      var DEFAULT_MAX_BUFFER = 1e3 * 1e3 * 100;
      var getEnv = ({ env: envOption, extendEnv, preferLocal, localDir, execPath }) => {
        const env = extendEnv ? __objSpread(__objSpread({}, process.env), envOption) : envOption;
        if (preferLocal) {
          return npmRunPath.env({ env, cwd: localDir, execPath });
        }
        return env;
      };
      var handleArguments = (file, args, options = {}) => {
        const parsed = crossSpawn._parse(file, args, options);
        file = parsed.command;
        args = parsed.args;
        options = parsed.options;
        options = __objSpread({
          maxBuffer: DEFAULT_MAX_BUFFER,
          buffer: true,
          stripFinalNewline: true,
          extendEnv: true,
          preferLocal: false,
          localDir: options.cwd || process.cwd(),
          execPath: process.execPath,
          encoding: "utf8",
          reject: true,
          cleanup: true,
          all: false,
          windowsHide: true
        }, options);
        options.env = getEnv(options);
        options.stdio = normalizeStdio(options);
        if (process.platform === "win32" && path3.basename(file, ".exe") === "cmd") {
          args.unshift("/q");
        }
        return { file, args, options, parsed };
      };
      var handleOutput = (options, value, error) => {
        if (typeof value !== "string" && !Buffer.isBuffer(value)) {
          return error === void 0 ? void 0 : "";
        }
        if (options.stripFinalNewline) {
          return stripFinalNewline(value);
        }
        return value;
      };
      var execa3 = (file, args, options) => {
        const parsed = handleArguments(file, args, options);
        const command = joinCommand(file, args);
        let spawned;
        try {
          spawned = childProcess.spawn(parsed.file, parsed.args, parsed.options);
        } catch (error) {
          const dummySpawned = new childProcess.ChildProcess();
          const errorPromise = Promise.reject(makeError({
            error,
            stdout: "",
            stderr: "",
            all: "",
            command,
            parsed,
            timedOut: false,
            isCanceled: false,
            killed: false
          }));
          return mergePromise(dummySpawned, errorPromise);
        }
        const spawnedPromise = getSpawnedPromise(spawned);
        const timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise);
        const processDone = setExitHandler(spawned, parsed.options, timedPromise);
        const context = { isCanceled: false };
        spawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned));
        spawned.cancel = spawnedCancel.bind(null, spawned, context);
        const handlePromise = async () => {
          const [{ error, exitCode, signal, timedOut }, stdoutResult, stderrResult, allResult] = await getSpawnedResult(spawned, parsed.options, processDone);
          const stdout = handleOutput(parsed.options, stdoutResult);
          const stderr = handleOutput(parsed.options, stderrResult);
          const all = handleOutput(parsed.options, allResult);
          if (error || exitCode !== 0 || signal !== null) {
            const returnedError = makeError({
              error,
              exitCode,
              signal,
              stdout,
              stderr,
              all,
              command,
              parsed,
              timedOut,
              isCanceled: context.isCanceled,
              killed: spawned.killed
            });
            if (!parsed.options.reject) {
              return returnedError;
            }
            throw returnedError;
          }
          return {
            command,
            exitCode: 0,
            stdout,
            stderr,
            all,
            failed: false,
            timedOut: false,
            isCanceled: false,
            killed: false
          };
        };
        const handlePromiseOnce = onetime(handlePromise);
        handleInput(spawned, parsed.options.input);
        spawned.all = makeAllStream(spawned, parsed.options);
        return mergePromise(spawned, handlePromiseOnce);
      };
      module2.exports = execa3;
      module2.exports.sync = (file, args, options) => {
        const parsed = handleArguments(file, args, options);
        const command = joinCommand(file, args);
        validateInputSync(parsed.options);
        let result;
        try {
          result = childProcess.spawnSync(parsed.file, parsed.args, parsed.options);
        } catch (error) {
          throw makeError({
            error,
            stdout: "",
            stderr: "",
            all: "",
            command,
            parsed,
            timedOut: false,
            isCanceled: false,
            killed: false
          });
        }
        const stdout = handleOutput(parsed.options, result.stdout, result.error);
        const stderr = handleOutput(parsed.options, result.stderr, result.error);
        if (result.error || result.status !== 0 || result.signal !== null) {
          const error = makeError({
            stdout,
            stderr,
            error: result.error,
            signal: result.signal,
            exitCode: result.status,
            command,
            parsed,
            timedOut: result.error && result.error.code === "ETIMEDOUT",
            isCanceled: false,
            killed: result.signal !== null
          });
          if (!parsed.options.reject) {
            return error;
          }
          throw error;
        }
        return {
          command,
          exitCode: 0,
          stdout,
          stderr,
          failed: false,
          timedOut: false,
          isCanceled: false,
          killed: false
        };
      };
      module2.exports.command = (command, options) => {
        const [file, ...args] = parseCommand(command);
        return execa3(file, args, options);
      };
      module2.exports.commandSync = (command, options) => {
        const [file, ...args] = parseCommand(command);
        return execa3.sync(file, args, options);
      };
      module2.exports.node = (scriptPath, args, options = {}) => {
        if (args && !Array.isArray(args) && typeof args === "object") {
          options = args;
          args = [];
        }
        const stdio = normalizeStdio.node(options);
        const defaultExecArgv = process.execArgv.filter((arg) => !arg.startsWith("--inspect"));
        const {
          nodePath = process.execPath,
          nodeOptions = defaultExecArgv
        } = options;
        return execa3(nodePath, [
          ...nodeOptions,
          scriptPath,
          ...Array.isArray(args) ? args : []
        ], __objSpread(__objSpread({}, options), {
          stdin: void 0,
          stdout: void 0,
          stderr: void 0,
          stdio,
          shell: false
        }));
      };
    });
    var require_yocto_queue = __commonJS2((exports2, module2) => {
      var Node = class {
        constructor(value) {
          this.value = value;
          this.next = void 0;
        }
      };
      var Queue = class {
        constructor() {
          this.clear();
        }
        enqueue(value) {
          const node = new Node(value);
          if (this._head) {
            this._tail.next = node;
            this._tail = node;
          } else {
            this._head = node;
            this._tail = node;
          }
          this._size++;
        }
        dequeue() {
          const current = this._head;
          if (!current) {
            return;
          }
          this._head = this._head.next;
          this._size--;
          return current.value;
        }
        clear() {
          this._head = void 0;
          this._tail = void 0;
          this._size = 0;
        }
        get size() {
          return this._size;
        }
        *[Symbol.iterator]() {
          let current = this._head;
          while (current) {
            yield current.value;
            current = current.next;
          }
        }
      };
      module2.exports = Queue;
    });
    var require_p_limit = __commonJS2((exports2, module2) => {
      "use strict";
      var Queue = require_yocto_queue();
      var pLimit = (concurrency) => {
        if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
          throw new TypeError("Expected `concurrency` to be a number from 1 and up");
        }
        const queue = new Queue();
        let activeCount = 0;
        const next = () => {
          activeCount--;
          if (queue.size > 0) {
            queue.dequeue()();
          }
        };
        const run22 = async (fn, resolve2, ...args) => {
          activeCount++;
          const result = (async () => fn(...args))();
          resolve2(result);
          try {
            await result;
          } catch (e2) {
          }
          next();
        };
        const enqueue = (fn, resolve2, ...args) => {
          queue.enqueue(run22.bind(null, fn, resolve2, ...args));
          (async () => {
            await Promise.resolve();
            if (activeCount < concurrency && queue.size > 0) {
              queue.dequeue()();
            }
          })();
        };
        const generator = (fn, ...args) => new Promise((resolve2) => {
          enqueue(fn, resolve2, ...args);
        });
        Object.defineProperties(generator, {
          activeCount: {
            get: () => activeCount
          },
          pendingCount: {
            get: () => queue.size
          },
          clearQueue: {
            value: () => {
              queue.clear();
            }
          }
        });
        return generator;
      };
      module2.exports = pLimit;
    });
    var require_p_locate = __commonJS2((exports2, module2) => {
      "use strict";
      var pLimit = require_p_limit();
      var EndError = class extends Error {
        constructor(value) {
          super();
          this.value = value;
        }
      };
      var testElement = async (element, tester) => tester(await element);
      var finder = async (element) => {
        const values = await Promise.all(element);
        if (values[1] === true) {
          throw new EndError(values[0]);
        }
        return false;
      };
      var pLocate = async (iterable, tester, options) => {
        options = __objSpread({
          concurrency: Infinity,
          preserveOrder: true
        }, options);
        const limit = pLimit(options.concurrency);
        const items = [...iterable].map((element) => [element, limit(testElement, element, tester)]);
        const checkLimit = pLimit(options.preserveOrder ? 1 : Infinity);
        try {
          await Promise.all(items.map((element) => checkLimit(finder, element)));
        } catch (error) {
          if (error instanceof EndError) {
            return error.value;
          }
          throw error;
        }
      };
      module2.exports = pLocate;
    });
    var require_locate_path = __commonJS2((exports2, module2) => {
      "use strict";
      var path3 = _chunkKRCSYS75js.__require.call(void 0, "path");
      var fs2 = _chunkKRCSYS75js.__require.call(void 0, "fs");
      var { promisify } = _chunkKRCSYS75js.__require.call(void 0, "util");
      var pLocate = require_p_locate();
      var fsStat = promisify(fs2.stat);
      var fsLStat = promisify(fs2.lstat);
      var typeMappings = {
        directory: "isDirectory",
        file: "isFile"
      };
      function checkType({ type }) {
        if (type in typeMappings) {
          return;
        }
        throw new Error(`Invalid type specified: ${type}`);
      }
      var matchType = (type, stat) => type === void 0 || stat[typeMappings[type]]();
      module2.exports = async (paths, options) => {
        options = __objSpread({
          cwd: process.cwd(),
          type: "file",
          allowSymlinks: true
        }, options);
        checkType(options);
        const statFn = options.allowSymlinks ? fsStat : fsLStat;
        return pLocate(paths, async (path_) => {
          try {
            const stat = await statFn(path3.resolve(options.cwd, path_));
            return matchType(options.type, stat);
          } catch (e3) {
            return false;
          }
        }, options);
      };
      module2.exports.sync = (paths, options) => {
        options = __objSpread({
          cwd: process.cwd(),
          allowSymlinks: true,
          type: "file"
        }, options);
        checkType(options);
        const statFn = options.allowSymlinks ? fs2.statSync : fs2.lstatSync;
        for (const path_ of paths) {
          try {
            const stat = statFn(path3.resolve(options.cwd, path_));
            if (matchType(options.type, stat)) {
              return path_;
            }
          } catch (e4) {
          }
        }
      };
    });
    var require_path_exists = __commonJS2((exports2, module2) => {
      "use strict";
      var fs2 = _chunkKRCSYS75js.__require.call(void 0, "fs");
      var { promisify } = _chunkKRCSYS75js.__require.call(void 0, "util");
      var pAccess = promisify(fs2.access);
      module2.exports = async (path3) => {
        try {
          await pAccess(path3);
          return true;
        } catch (_) {
          return false;
        }
      };
      module2.exports.sync = (path3) => {
        try {
          fs2.accessSync(path3);
          return true;
        } catch (_) {
          return false;
        }
      };
    });
    var require_find_up = __commonJS2((exports2, module2) => {
      "use strict";
      var path3 = _chunkKRCSYS75js.__require.call(void 0, "path");
      var locatePath = require_locate_path();
      var pathExists = require_path_exists();
      var stop = Symbol("findUp.stop");
      module2.exports = async (name, options = {}) => {
        let directory = path3.resolve(options.cwd || "");
        const { root } = path3.parse(directory);
        const paths = [].concat(name);
        const runMatcher = async (locateOptions) => {
          if (typeof name !== "function") {
            return locatePath(paths, locateOptions);
          }
          const foundPath = await name(locateOptions.cwd);
          if (typeof foundPath === "string") {
            return locatePath([foundPath], locateOptions);
          }
          return foundPath;
        };
        while (true) {
          const foundPath = await runMatcher(__objSpread(__objSpread({}, options), { cwd: directory }));
          if (foundPath === stop) {
            return;
          }
          if (foundPath) {
            return path3.resolve(directory, foundPath);
          }
          if (directory === root) {
            return;
          }
          directory = path3.dirname(directory);
        }
      };
      module2.exports.sync = (name, options = {}) => {
        let directory = path3.resolve(options.cwd || "");
        const { root } = path3.parse(directory);
        const paths = [].concat(name);
        const runMatcher = (locateOptions) => {
          if (typeof name !== "function") {
            return locatePath.sync(paths, locateOptions);
          }
          const foundPath = name(locateOptions.cwd);
          if (typeof foundPath === "string") {
            return locatePath.sync([foundPath], locateOptions);
          }
          return foundPath;
        };
        while (true) {
          const foundPath = runMatcher(__objSpread(__objSpread({}, options), { cwd: directory }));
          if (foundPath === stop) {
            return;
          }
          if (foundPath) {
            return path3.resolve(directory, foundPath);
          }
          if (directory === root) {
            return;
          }
          directory = path3.dirname(directory);
        }
      };
      module2.exports.exists = pathExists;
      module2.exports.sync.exists = pathExists.sync;
      module2.exports.stop = stop;
    });
    var require_has_flag = __commonJS2((exports2, module2) => {
      "use strict";
      module2.exports = (flag, argv = process.argv) => {
        const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
        const position = argv.indexOf(prefix + flag);
        const terminatorPosition = argv.indexOf("--");
        return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
      };
    });
    var require_supports_color = __commonJS2((exports2, module2) => {
      "use strict";
      var os2 = _chunkKRCSYS75js.__require.call(void 0, "os");
      var tty = _chunkKRCSYS75js.__require.call(void 0, "tty");
      var hasFlag = require_has_flag();
      var { env } = process;
      var forceColor;
      if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
        forceColor = 0;
      } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
        forceColor = 1;
      }
      if ("FORCE_COLOR" in env) {
        if (env.FORCE_COLOR === "true") {
          forceColor = 1;
        } else if (env.FORCE_COLOR === "false") {
          forceColor = 0;
        } else {
          forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
        }
      }
      function translateLevel(level) {
        if (level === 0) {
          return false;
        }
        return {
          level,
          hasBasic: true,
          has256: level >= 2,
          has16m: level >= 3
        };
      }
      function supportsColor(haveStream, streamIsTTY) {
        if (forceColor === 0) {
          return 0;
        }
        if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
          return 3;
        }
        if (hasFlag("color=256")) {
          return 2;
        }
        if (haveStream && !streamIsTTY && forceColor === void 0) {
          return 0;
        }
        const min = forceColor || 0;
        if (env.TERM === "dumb") {
          return min;
        }
        if (process.platform === "win32") {
          const osRelease = os2.release().split(".");
          if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
            return Number(osRelease[2]) >= 14931 ? 3 : 2;
          }
          return 1;
        }
        if ("CI" in env) {
          if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
            return 1;
          }
          return min;
        }
        if ("TEAMCITY_VERSION" in env) {
          return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
        }
        if (env.COLORTERM === "truecolor") {
          return 3;
        }
        if ("TERM_PROGRAM" in env) {
          const version2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
          switch (env.TERM_PROGRAM) {
            case "iTerm.app":
              return version2 >= 3 ? 3 : 2;
            case "Apple_Terminal":
              return 2;
          }
        }
        if (/-256(color)?$/i.test(env.TERM)) {
          return 2;
        }
        if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
          return 1;
        }
        if ("COLORTERM" in env) {
          return 1;
        }
        return min;
      }
      function getSupportLevel(stream) {
        const level = supportsColor(stream, stream && stream.isTTY);
        return translateLevel(level);
      }
      module2.exports = {
        supportsColor: getSupportLevel,
        stdout: translateLevel(supportsColor(true, tty.isatty(1))),
        stderr: translateLevel(supportsColor(true, tty.isatty(2)))
      };
    });
    var require_supports_hyperlinks = __commonJS2((exports2, module2) => {
      "use strict";
      var supportsColor = require_supports_color();
      var hasFlag = require_has_flag();
      function parseVersion(versionString) {
        if (/^\d{3,4}$/.test(versionString)) {
          const m = /(\d{1,2})(\d{2})/.exec(versionString);
          return {
            major: 0,
            minor: parseInt(m[1], 10),
            patch: parseInt(m[2], 10)
          };
        }
        const versions = (versionString || "").split(".").map((n) => parseInt(n, 10));
        return {
          major: versions[0],
          minor: versions[1],
          patch: versions[2]
        };
      }
      function supportsHyperlink(stream) {
        const { env } = process;
        if ("FORCE_HYPERLINK" in env) {
          return !(env.FORCE_HYPERLINK.length > 0 && parseInt(env.FORCE_HYPERLINK, 10) === 0);
        }
        if (hasFlag("no-hyperlink") || hasFlag("no-hyperlinks") || hasFlag("hyperlink=false") || hasFlag("hyperlink=never")) {
          return false;
        }
        if (hasFlag("hyperlink=true") || hasFlag("hyperlink=always")) {
          return true;
        }
        if (!supportsColor.supportsColor(stream)) {
          return false;
        }
        if (stream && !stream.isTTY) {
          return false;
        }
        if (process.platform === "win32") {
          return false;
        }
        if ("NETLIFY" in env) {
          return true;
        }
        if ("CI" in env) {
          return false;
        }
        if ("TEAMCITY_VERSION" in env) {
          return false;
        }
        if ("TERM_PROGRAM" in env) {
          const version2 = parseVersion(env.TERM_PROGRAM_VERSION);
          switch (env.TERM_PROGRAM) {
            case "iTerm.app":
              if (version2.major === 3) {
                return version2.minor >= 1;
              }
              return version2.major > 3;
          }
        }
        if ("VTE_VERSION" in env) {
          if (env.VTE_VERSION === "0.50.0") {
            return false;
          }
          const version2 = parseVersion(env.VTE_VERSION);
          return version2.major > 0 || version2.minor >= 50;
        }
        return false;
      }
      module2.exports = {
        supportsHyperlink,
        stdout: supportsHyperlink(process.stdout),
        stderr: supportsHyperlink(process.stderr)
      };
    });
    var _os2 = _chunkKRCSYS75js.__require.call(void 0, "os");
    var _os3 = _interopRequireDefault(_os2);
    var _child_process = _chunkKRCSYS75js.__require.call(void 0, "child_process");
    function remove(arr, v) {
      const index = arr.indexOf(v);
      if (index >= 0)
        arr.splice(index, 1);
      return arr;
    }
    function exclude(arr, v) {
      return remove(arr.slice(), v);
    }
    function cmdExists(cmd) {
      try {
        _child_process.execSync.call(void 0, _os3.default.platform() === "win32" ? `cmd /c "(help ${cmd} > nul || exit 0) && where ${cmd} > nul 2> nul"` : `command -v ${cmd}`);
        return true;
      } catch (e5) {
        return false;
      }
    }
    var npmRun = (agent) => (args) => {
      if (args.length > 1)
        return `${agent} run ${args[0]} -- ${args.slice(1).join(" ")}`;
      else
        return `${agent} run ${args[0]}`;
    };
    var AGENTS = {
      npm: {
        run: npmRun("npm"),
        install: "npm i",
        frozen: "npm ci",
        global: "npm i -g {0}",
        add: "npm i {0}",
        upgrade: "npm update {0}",
        "upgrade-interactive": null,
        execute: "npx {0}",
        uninstall: "npm uninstall {0}",
        global_uninstall: "npm uninstall -g {0}"
      },
      yarn: {
        run: "yarn run {0}",
        install: "yarn install",
        frozen: "yarn install --frozen-lockfile",
        global: "yarn global add {0}",
        add: "yarn add {0}",
        upgrade: "yarn upgrade {0}",
        "upgrade-interactive": "yarn upgrade-interactive",
        execute: "yarn dls {0}",
        uninstall: "yarn remove {0}",
        global_uninstall: "yarn global remove {0}"
      },
      pnpm: {
        run: npmRun("pnpm"),
        install: "pnpm i",
        frozen: "pnpm i --frozen-lockfile",
        global: "pnpm i -g {0}",
        add: "pnpm i {0}",
        upgrade: "pnpm update {0}",
        "upgrade-interactive": "pnpm update -i",
        execute: "pnpx {0}",
        uninstall: "pnpm remove {0}",
        global_uninstall: "pnpm remove -g {0}"
      }
    };
    var agents = Object.keys(AGENTS);
    var LOCKS = {
      "pnpm-lock.yaml": "pnpm",
      "yarn.lock": "yarn",
      "package-lock.json": "npm"
    };
    var INSTALL_PAGE = {
      pnpm: "https://pnpm.js.org/en/installation",
      yarn: "https://yarnpkg.com/getting-started/install",
      npm: "https://www.npmjs.com/get-npm"
    };
    function getCommand(agent, command, args = []) {
      if (!(agent in AGENTS))
        throw new Error(`Unsupported agent "${agent}"`);
      const c = AGENTS[agent][command];
      if (typeof c === "function")
        return c(args);
      if (!c)
        throw new Error(`Command "${command}" is not support by agent "${agent}"`);
      return c.replace("{0}", args.join(" ")).trim();
    }
    function parseNi2(agent, args, hasLock) {
      if (args.length === 0)
        return getCommand(agent, "install");
      if (args.includes("-g"))
        return getCommand(agent, "global", exclude(args, "-g"));
      if (args.includes("--frozen-if-present")) {
        args = exclude(args, "--frozen-if-present");
        return getCommand(agent, hasLock ? "frozen" : "install", args);
      }
      if (args.includes("--frozen"))
        return getCommand(agent, "frozen", exclude(args, "--frozen"));
      return getCommand(agent, "add", args);
    }
    function parseNr(agent, args) {
      if (args.length === 0)
        args.push("start");
      if (args.includes("--if-present")) {
        args = exclude(args, "--if-present");
        args[0] = `--if-present ${args[0]}`;
      }
      return getCommand(agent, "run", args);
    }
    function parseNu(agent, args) {
      if (args.includes("-i"))
        return getCommand(agent, "upgrade-interactive", exclude(args, "-i"));
      return getCommand(agent, "upgrade", args);
    }
    function parseNrm(agent, args) {
      if (args.includes("-g"))
        return getCommand(agent, "global_uninstall", exclude(args, "-g"));
      return getCommand(agent, "uninstall", args);
    }
    function parseNx(agent, args) {
      return getCommand(agent, "execute", args);
    }
    var import_ini = __toModule2(require_ini());
    var _fs = _chunkKRCSYS75js.__require.call(void 0, "fs");
    var _fs2 = _interopRequireDefault(_fs);
    var _path = _chunkKRCSYS75js.__require.call(void 0, "path");
    var _path2 = _interopRequireDefault(_path);
    var home = process.platform === "win32" ? process.env.USERPROFILE : process.env.HOME;
    var rcPath = _path2.default.join(home || "~/", ".nirc");
    var defaultConfig = {
      defaultAgent: "prompt",
      globalAgent: "npm"
    };
    var config;
    function getConfig() {
      if (!config) {
        if (!_fs2.default.existsSync(rcPath))
          config = defaultConfig;
        else
          config = Object.assign({}, defaultConfig, import_ini.default.parse(_fs2.default.readFileSync(rcPath, "utf-8")));
      }
      return config;
    }
    function getDefaultAgent() {
      const agent = getConfig().defaultAgent;
      if (agent === "prompt" && process.env.CI)
        return "npm";
      return agent;
    }
    function getGlobalAgent() {
      return getConfig().globalAgent;
    }
    var import_execa = __toModule2(require_execa());
    var import_find_up = __toModule2(require_find_up());
    var ESC = "[";
    var OSC = "]";
    var BEL = "\x07";
    var SEP = ";";
    var isTerminalApp = process.env.TERM_PROGRAM === "Apple_Terminal";
    var ansiEscapes = {};
    ansiEscapes.cursorTo = (x, y) => {
      if (typeof x !== "number") {
        throw new TypeError("The `x` argument is required");
      }
      if (typeof y !== "number") {
        return ESC + (x + 1) + "G";
      }
      return ESC + (y + 1) + ";" + (x + 1) + "H";
    };
    ansiEscapes.cursorMove = (x, y) => {
      if (typeof x !== "number") {
        throw new TypeError("The `x` argument is required");
      }
      let returnValue = "";
      if (x < 0) {
        returnValue += ESC + -x + "D";
      } else if (x > 0) {
        returnValue += ESC + x + "C";
      }
      if (y < 0) {
        returnValue += ESC + -y + "A";
      } else if (y > 0) {
        returnValue += ESC + y + "B";
      }
      return returnValue;
    };
    ansiEscapes.cursorUp = (count = 1) => ESC + count + "A";
    ansiEscapes.cursorDown = (count = 1) => ESC + count + "B";
    ansiEscapes.cursorForward = (count = 1) => ESC + count + "C";
    ansiEscapes.cursorBackward = (count = 1) => ESC + count + "D";
    ansiEscapes.cursorLeft = ESC + "G";
    ansiEscapes.cursorSavePosition = isTerminalApp ? "7" : ESC + "s";
    ansiEscapes.cursorRestorePosition = isTerminalApp ? "8" : ESC + "u";
    ansiEscapes.cursorGetPosition = ESC + "6n";
    ansiEscapes.cursorNextLine = ESC + "E";
    ansiEscapes.cursorPrevLine = ESC + "F";
    ansiEscapes.cursorHide = ESC + "?25l";
    ansiEscapes.cursorShow = ESC + "?25h";
    ansiEscapes.eraseLines = (count) => {
      let clear = "";
      for (let i = 0; i < count; i++) {
        clear += ansiEscapes.eraseLine + (i < count - 1 ? ansiEscapes.cursorUp() : "");
      }
      if (count) {
        clear += ansiEscapes.cursorLeft;
      }
      return clear;
    };
    ansiEscapes.eraseEndLine = ESC + "K";
    ansiEscapes.eraseStartLine = ESC + "1K";
    ansiEscapes.eraseLine = ESC + "2K";
    ansiEscapes.eraseDown = ESC + "J";
    ansiEscapes.eraseUp = ESC + "1J";
    ansiEscapes.eraseScreen = ESC + "2J";
    ansiEscapes.scrollUp = ESC + "S";
    ansiEscapes.scrollDown = ESC + "T";
    ansiEscapes.clearScreen = "c";
    ansiEscapes.clearTerminal = process.platform === "win32" ? `${ansiEscapes.eraseScreen}${ESC}0f` : `${ansiEscapes.eraseScreen}${ESC}3J${ESC}H`;
    ansiEscapes.beep = BEL;
    ansiEscapes.link = (text, url) => {
      return [
        OSC,
        "8",
        SEP,
        SEP,
        url,
        BEL,
        text,
        OSC,
        "8",
        SEP,
        SEP,
        BEL
      ].join("");
    };
    ansiEscapes.image = (buffer, options = {}) => {
      let returnValue = `${OSC}1337;File=inline=1`;
      if (options.width) {
        returnValue += `;width=${options.width}`;
      }
      if (options.height) {
        returnValue += `;height=${options.height}`;
      }
      if (options.preserveAspectRatio === false) {
        returnValue += ";preserveAspectRatio=0";
      }
      return returnValue + ":" + buffer.toString("base64") + BEL;
    };
    ansiEscapes.iTerm = {
      setCwd: (cwd = process.cwd()) => `${OSC}50;CurrentDir=${cwd}${BEL}`,
      annotation: (message, options = {}) => {
        let returnValue = `${OSC}1337;`;
        const hasX = typeof options.x !== "undefined";
        const hasY = typeof options.y !== "undefined";
        if ((hasX || hasY) && !(hasX && hasY && typeof options.length !== "undefined")) {
          throw new Error("`x`, `y` and `length` must be defined when `x` or `y` is defined");
        }
        message = message.replace(/\|/g, "");
        returnValue += options.isHidden ? "AddHiddenAnnotation=" : "AddAnnotation=";
        if (options.length > 0) {
          returnValue += (hasX ? [message, options.length, options.x, options.y] : [options.length, message]).join("|");
        } else {
          returnValue += message;
        }
        return returnValue + BEL;
      }
    };
    var ansi_escapes_default = ansiEscapes;
    var import_supports_hyperlinks = __toModule2(require_supports_hyperlinks());
    function terminalLink(text, url, _a = {}) {
      var _b = _a, { target = "stdout" } = _b, options = __objRest(_b, ["target"]);
      if (!import_supports_hyperlinks.default[target]) {
        if (options.fallback === false) {
          return text;
        }
        return typeof options.fallback === "function" ? options.fallback(text, url) : `${text} (\u200B${url}\u200B)`;
      }
      return ansi_escapes_default.link(text, url);
    }
    terminalLink.isSupported = import_supports_hyperlinks.default.stdout;
    terminalLink.stderr = (text, url, options = {}) => terminalLink(text, url, __objSpread({ target: "stderr" }, options));
    terminalLink.stderr.isSupported = import_supports_hyperlinks.default.stderr;
    var import_prompts2 = __toModule2(require_prompts3());
    async function detect({ autoInstall }) {
      const result = await (0, import_find_up.default)(Object.keys(LOCKS));
      const agent = result ? LOCKS[_path2.default.basename(result)] : null;
      if (agent && !cmdExists(agent)) {
        if (!autoInstall) {
          console.warn(`Detected ${agent} but it doesn't seem to be installed.
`);
          if (process.env.CI)
            process.exit(1);
          const link = terminalLink(agent, INSTALL_PAGE[agent]);
          const { tryInstall } = await (0, import_prompts2.default)({
            name: "tryInstall",
            type: "confirm",
            message: `Would you like to globally install ${link}?`
          });
          if (!tryInstall)
            process.exit(1);
        }
        await import_execa.default.command(`npm i -g ${agent}`, { stdio: "inherit" });
      }
      return agent;
    }
    var import_prompts22 = __toModule2(require_prompts3());
    var import_execa2 = __toModule2(require_execa());
    var DEBUG_SIGN = "?";
    async function runCli(fn, options = {}) {
      const args = process.argv.slice(2).filter(Boolean);
      try {
        await run2(fn, args, options);
      } catch (error) {
        process.exit(1);
      }
    }
    async function run2(fn, args, options = {}) {
      const debug2 = args.includes(DEBUG_SIGN);
      if (debug2)
        remove(args, DEBUG_SIGN);
      const isGlobal = args.includes("-g");
      let command;
      if (isGlobal) {
        command = await fn(getGlobalAgent(), args);
      } else {
        let agent = await detect(options) || getDefaultAgent();
        if (agent === "prompt") {
          agent = (await (0, import_prompts22.default)({
            name: "agent",
            type: "select",
            message: "Choose the agent",
            choices: agents.map((value) => ({ title: value, value }))
          })).agent;
          if (!agent)
            return;
        }
        command = await fn(agent, args, Boolean(agent));
      }
      if (!command)
        return;
      if (debug2) {
        console.log(command);
        return;
      }
      await import_execa2.default.command(command, { stdio: "inherit", encoding: "utf-8" });
    }
    exports.__toModule = __toModule2;
    exports.remove = remove;
    exports.exclude = exclude;
    exports.cmdExists = cmdExists;
    exports.getCommand = getCommand;
    exports.parseNi = parseNi2;
    exports.parseNr = parseNr;
    exports.parseNu = parseNu;
    exports.parseNrm = parseNrm;
    exports.parseNx = parseNx;
    exports.require_prompts = require_prompts3;
    exports.getConfig = getConfig;
    exports.getDefaultAgent = getDefaultAgent;
    exports.getGlobalAgent = getGlobalAgent;
    exports.detect = detect;
    exports.runCli = runCli;
    exports.run = run2;
  }
});

// ../../node_modules/.pnpm/@antfu+ni@0.7.0/node_modules/@antfu/ni/dist/index.js
var require_dist = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/@antfu+ni@0.7.0/node_modules/@antfu/ni/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _chunkJBT3DO44js = require_chunk_JBT3DO44();
    exports.cmdExists = _chunkJBT3DO44js.cmdExists;
    exports.detect = _chunkJBT3DO44js.detect;
    exports.exclude = _chunkJBT3DO44js.exclude;
    exports.getCommand = _chunkJBT3DO44js.getCommand;
    exports.getConfig = _chunkJBT3DO44js.getConfig;
    exports.getDefaultAgent = _chunkJBT3DO44js.getDefaultAgent;
    exports.getGlobalAgent = _chunkJBT3DO44js.getGlobalAgent;
    exports.parseNi = _chunkJBT3DO44js.parseNi;
    exports.parseNr = _chunkJBT3DO44js.parseNr;
    exports.parseNrm = _chunkJBT3DO44js.parseNrm;
    exports.parseNu = _chunkJBT3DO44js.parseNu;
    exports.parseNx = _chunkJBT3DO44js.parseNx;
    exports.remove = _chunkJBT3DO44js.remove;
    exports.run = _chunkJBT3DO44js.run;
    exports.runCli = _chunkJBT3DO44js.runCli;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/internal/constants.js
var require_constants = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/internal/constants.js"(exports, module) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    module.exports = {
      SEMVER_SPEC_VERSION,
      MAX_LENGTH,
      MAX_SAFE_INTEGER,
      MAX_SAFE_COMPONENT_LENGTH
    };
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/internal/debug.js
var require_debug = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/internal/debug.js"(exports, module) {
    var debug2 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module.exports = debug2;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/internal/re.js
var require_re = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/internal/re.js"(exports, module) {
    var { MAX_SAFE_COMPONENT_LENGTH } = require_constants();
    var debug2 = require_debug();
    exports = module.exports = {};
    var re = exports.re = [];
    var src = exports.src = [];
    var t = exports.t = {};
    var R = 0;
    var createToken = (name, value, isGlobal) => {
      const index = R++;
      debug2(index, value);
      t[name] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+");
    createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0.0.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/internal/parse-options.js
var require_parse_options = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/internal/parse-options.js"(exports, module) {
    var opts = ["includePrerelease", "loose", "rtl"];
    var parseOptions = (options) => !options ? {} : typeof options !== "object" ? { loose: true } : opts.filter((k) => options[k]).reduce((options2, k) => {
      options2[k] = true;
      return options2;
    }, {});
    module.exports = parseOptions;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/internal/identifiers.js
var require_identifiers = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/internal/identifiers.js"(exports, module) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/classes/semver.js
var require_semver = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/classes/semver.js"(exports, module) {
    var debug2 = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class {
      constructor(version2, options) {
        options = parseOptions(options);
        if (version2 instanceof SemVer) {
          if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
            return version2;
          } else {
            version2 = version2.version;
          }
        } else if (typeof version2 !== "string") {
          throw new TypeError(`Invalid Version: ${version2}`);
        }
        if (version2.length > MAX_LENGTH) {
          throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
        }
        debug2("SemVer", version2, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version2.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version2}`);
        }
        this.raw = version2;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug2("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug2("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug2("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      inc(release, identifier) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier);
            this.inc("pre", identifier);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier);
            }
            this.inc("pre", identifier);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre":
            if (this.prerelease.length === 0) {
              this.prerelease = [0];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                this.prerelease.push(0);
              }
            }
            if (identifier) {
              if (this.prerelease[0] === identifier) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = [identifier, 0];
                }
              } else {
                this.prerelease = [identifier, 0];
              }
            }
            break;
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.format();
        this.raw = this.version;
        return this;
      }
    };
    module.exports = SemVer;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/parse.js
var require_parse = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/parse.js"(exports, module) {
    var { MAX_LENGTH } = require_constants();
    var { re, t } = require_re();
    var SemVer = require_semver();
    var parseOptions = require_parse_options();
    var parse = (version2, options) => {
      options = parseOptions(options);
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 !== "string") {
        return null;
      }
      if (version2.length > MAX_LENGTH) {
        return null;
      }
      const r = options.loose ? re[t.LOOSE] : re[t.FULL];
      if (!r.test(version2)) {
        return null;
      }
      try {
        return new SemVer(version2, options);
      } catch (er) {
        return null;
      }
    };
    module.exports = parse;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/valid.js
var require_valid = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/valid.js"(exports, module) {
    var parse = require_parse();
    var valid = (version2, options) => {
      const v = parse(version2, options);
      return v ? v.version : null;
    };
    module.exports = valid;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/clean.js
var require_clean = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/clean.js"(exports, module) {
    var parse = require_parse();
    var clean = (version2, options) => {
      const s = parse(version2.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module.exports = clean;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/inc.js
var require_inc = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/inc.js"(exports, module) {
    var SemVer = require_semver();
    var inc = (version2, release, options, identifier) => {
      if (typeof options === "string") {
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(version2, options).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    };
    module.exports = inc;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/compare.js
var require_compare = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/compare.js"(exports, module) {
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module.exports = compare;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/eq.js
var require_eq = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/eq.js"(exports, module) {
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module.exports = eq;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/diff.js
var require_diff = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/diff.js"(exports, module) {
    var parse = require_parse();
    var eq = require_eq();
    var diff = (version1, version2) => {
      if (eq(version1, version2)) {
        return null;
      } else {
        const v1 = parse(version1);
        const v2 = parse(version2);
        const hasPre = v1.prerelease.length || v2.prerelease.length;
        const prefix = hasPre ? "pre" : "";
        const defaultResult = hasPre ? "prerelease" : "";
        for (const key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    };
    module.exports = diff;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/major.js
var require_major = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/major.js"(exports, module) {
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module.exports = major;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/minor.js
var require_minor = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/minor.js"(exports, module) {
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module.exports = minor;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/patch.js
var require_patch = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/patch.js"(exports, module) {
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module.exports = patch;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/prerelease.js
var require_prerelease = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/prerelease.js"(exports, module) {
    var parse = require_parse();
    var prerelease = (version2, options) => {
      const parsed = parse(version2, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module.exports = prerelease;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/rcompare.js
var require_rcompare = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/rcompare.js"(exports, module) {
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module.exports = rcompare;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/compare-loose.js
var require_compare_loose = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/compare-loose.js"(exports, module) {
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module.exports = compareLoose;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/compare-build.js
var require_compare_build = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/compare-build.js"(exports, module) {
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module.exports = compareBuild;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/sort.js
var require_sort = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/sort.js"(exports, module) {
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module.exports = sort;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/rsort.js
var require_rsort = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/rsort.js"(exports, module) {
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module.exports = rsort;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/gt.js
var require_gt = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/gt.js"(exports, module) {
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module.exports = gt;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/lt.js
var require_lt = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/lt.js"(exports, module) {
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module.exports = lt;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/neq.js
var require_neq = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/neq.js"(exports, module) {
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module.exports = neq;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/gte.js
var require_gte = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/gte.js"(exports, module) {
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module.exports = gte;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/lte.js
var require_lte = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/lte.js"(exports, module) {
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module.exports = lte;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/cmp.js
var require_cmp = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/cmp.js"(exports, module) {
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module.exports = cmp;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/coerce.js
var require_coerce = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/coerce.js"(exports, module) {
    var SemVer = require_semver();
    var parse = require_parse();
    var { re, t } = require_re();
    var coerce = (version2, options) => {
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 === "number") {
        version2 = String(version2);
      }
      if (typeof version2 !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version2.match(re[t.COERCE]);
      } else {
        let next;
        while ((next = re[t.COERCERTL].exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        re[t.COERCERTL].lastIndex = -1;
      }
      if (match === null)
        return null;
      return parse(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
    };
    module.exports = coerce;
  }
});

// ../../node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/iterator.js
var require_iterator = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/iterator.js"(exports, module) {
    "use strict";
    module.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// ../../node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/yallist.js
var require_yallist = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/yallist.js"(exports, module) {
    "use strict";
    module.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self = this;
      if (!(self instanceof Yallist)) {
        self = new Yallist();
      }
      self.tail = null;
      self.head = null;
      self.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self.push(arguments[i]);
        }
      }
      return self;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 0; i < nodes.length; i++) {
        walker = insert(this, walker, nodes[i]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self, node, value) {
      var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);
      if (inserted.next === null) {
        self.tail = inserted;
      }
      if (inserted.prev === null) {
        self.head = inserted;
      }
      self.length++;
      return inserted;
    }
    function push(self, item) {
      self.tail = new Node(item, self.tail, null, self);
      if (!self.head) {
        self.head = self.tail;
      }
      self.length++;
    }
    function unshift(self, item) {
      self.head = new Node(item, null, self.head, self);
      if (!self.tail) {
        self.tail = self.head;
      }
      self.length++;
    }
    function Node(value, prev, next, list) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  }
});

// ../../node_modules/.pnpm/lru-cache@6.0.0/node_modules/lru-cache/index.js
var require_lru_cache = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/lru-cache@6.0.0/node_modules/lru-cache/index.js"(exports, module) {
    "use strict";
    var Yallist = require_yallist();
    var MAX = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = () => 1;
    var LRUCache = class {
      constructor(options) {
        if (typeof options === "number")
          options = { max: options };
        if (!options)
          options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max = this[MAX] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
      }
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit) => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          const prev = walker.prev;
          forEachStep(this, fn, walker, thisp);
          walker = prev;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          const next = walker.next;
          forEachStep(this, fn, walker, thisp);
          walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k) => k.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k) => k.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h) => h);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key));
            return false;
          }
          const node = this[CACHE].get(key);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key, item.value);
          }
          item.now = now;
          item.maxAge = maxAge;
          item.value = value;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim(this);
          return true;
        }
        const hit = new Entry(key, value, len, now, maxAge);
        if (hit.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key, value);
          return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
      }
      has(key) {
        if (!this[CACHE].has(key))
          return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get(this, key, true);
      }
      peek(key) {
        return get(this, key, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del(this, node);
        return node.value;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        const now = Date.now();
        for (let l = arr.length - 1; l >= 0; l--) {
          const hit = arr[l];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now;
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value, key) => get(this, key, false));
      }
    };
    var get = (self, key, doUse) => {
      const node = self[CACHE].get(key);
      if (node) {
        const hit = node.value;
        if (isStale(self, hit)) {
          del(self, node);
          if (!self[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self[LRU_LIST].unshiftNode(node);
          }
        }
        return hit.value;
      }
    };
    var isStale = (self, hit) => {
      if (!hit || !hit.maxAge && !self[MAX_AGE])
        return false;
      const diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self[MAX_AGE] && diff > self[MAX_AGE];
    };
    var trim = (self) => {
      if (self[LENGTH] > self[MAX]) {
        for (let walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null; ) {
          const prev = walker.prev;
          del(self, walker);
          walker = prev;
        }
      }
    };
    var del = (self, node) => {
      if (node) {
        const hit = node.value;
        if (self[DISPOSE])
          self[DISPOSE](hit.key, hit.value);
        self[LENGTH] -= hit.length;
        self[CACHE].delete(hit.key);
        self[LRU_LIST].removeNode(node);
      }
    };
    var Entry = class {
      constructor(key, value, length, now, maxAge) {
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = (self, fn, node, thisp) => {
      let hit = node.value;
      if (isStale(self, hit)) {
        del(self, node);
        if (!self[ALLOW_STALE])
          hit = void 0;
      }
      if (hit)
        fn.call(thisp, hit.value, hit.key, self);
    };
    module.exports = LRUCache;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/classes/range.js
var require_range = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/classes/range.js"(exports, module) {
    var Range = class {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.format();
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range;
        this.set = range.split(/\s*\|\|\s*/).map((range2) => this.parseRange(range2.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${range}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0)
            this.set = [first];
          else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.format();
      }
      format() {
        this.range = this.set.map((comps) => {
          return comps.join(" ").trim();
        }).join("||").trim();
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        range = range.trim();
        const memoOpts = Object.keys(this.options).join(",");
        const memoKey = `parseRange:${memoOpts}:${range}`;
        const cached = cache.get(memoKey);
        if (cached)
          return cached;
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug2("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug2("comparator trim", range, re[t.COMPARATORTRIM]);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        range = range.split(/\s+/).join(" ");
        const compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options)).filter(this.options.loose ? (comp) => !!comp.match(compRe) : () => true).map((comp) => new Comparator(comp, this.options));
        const l = rangeList.length;
        const rangeMap = new Map();
        for (const comp of rangeList) {
          if (isNullSet(comp))
            return [comp];
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has(""))
          rangeMap.delete("");
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      test(version2) {
        if (!version2) {
          return false;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version2, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module.exports = Range;
    var LRU = require_lru_cache();
    var cache = new LRU({ max: 1e3 });
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug2 = require_debug();
    var SemVer = require_semver();
    var {
      re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug2("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug2("caret", comp);
      comp = replaceTildes(comp, options);
      debug2("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug2("xrange", comp);
      comp = replaceStars(comp, options);
      debug2("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
      return replaceTilde(comp2, options);
    }).join(" ");
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug2("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug2("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug2("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
      return replaceCaret(comp2, options);
    }).join(" ");
    var replaceCaret = (comp, options) => {
      debug2("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug2("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug2("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug2("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug2("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug2("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((comp2) => {
        return replaceXRange(comp2, options);
      }).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug2("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<")
            pr = "-0";
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug2("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug2("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug2("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version2, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version2)) {
          return false;
        }
      }
      if (version2.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug2(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/classes/comparator.js
var require_comparator = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/classes/comparator.js"(exports, module) {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        debug2("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug2("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version2) {
        debug2("Comparator.test", version2, this.options.loose);
        if (this.semver === ANY || version2 === ANY) {
          return true;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version2, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (!options || typeof options !== "object") {
          options = {
            loose: !!options,
            includePrerelease: false
          };
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        const sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
        const sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
        const sameSemVer = this.semver.version === comp.semver.version;
        const differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
        const oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<");
        const oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
        return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
      }
    };
    module.exports = Comparator;
    var parseOptions = require_parse_options();
    var { re, t } = require_re();
    var cmp = require_cmp();
    var debug2 = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/satisfies.js
var require_satisfies = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/satisfies.js"(exports, module) {
    var Range = require_range();
    var satisfies2 = (version2, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version2);
    };
    module.exports = satisfies2;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/to-comparators.js
var require_to_comparators = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/to-comparators.js"(exports, module) {
    var Range = require_range();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module.exports = toComparators;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/max-satisfying.js"(exports, module) {
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module.exports = maxSatisfying;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/min-satisfying.js"(exports, module) {
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module.exports = minSatisfying;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/min-version.js
var require_min_version = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/min-version.js"(exports, module) {
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin)))
          minver = setMin;
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module.exports = minVersion;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/valid.js
var require_valid2 = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/valid.js"(exports, module) {
    var Range = require_range();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module.exports = validRange;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/outside.js
var require_outside = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/outside.js"(exports, module) {
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies2 = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version2, range, hilo, options) => {
      version2 = new SemVer(version2, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies2(version2, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module.exports = outside;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/gtr.js
var require_gtr = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/gtr.js"(exports, module) {
    var outside = require_outside();
    var gtr = (version2, range, options) => outside(version2, range, ">", options);
    module.exports = gtr;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/ltr.js
var require_ltr = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/ltr.js"(exports, module) {
    var outside = require_outside();
    var ltr = (version2, range, options) => outside(version2, range, "<", options);
    module.exports = ltr;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/intersects.js
var require_intersects = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/intersects.js"(exports, module) {
    var Range = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    };
    module.exports = intersects;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/simplify.js
var require_simplify = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/simplify.js"(exports, module) {
    var satisfies2 = require_satisfies();
    var compare = require_compare();
    module.exports = (versions, range, options) => {
      const set = [];
      let min = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options));
      for (const version2 of v) {
        const included = satisfies2(version2, range, options);
        if (included) {
          prev = version2;
          if (!min)
            min = version2;
        } else {
          if (prev) {
            set.push([min, prev]);
          }
          prev = null;
          min = null;
        }
      }
      if (min)
        set.push([min, null]);
      const ranges = [];
      for (const [min2, max] of set) {
        if (min2 === max)
          ranges.push(min2);
        else if (!max && min2 === v[0])
          ranges.push("*");
        else if (!max)
          ranges.push(`>=${min2}`);
        else if (min2 === v[0])
          ranges.push(`<=${max}`);
        else
          ranges.push(`${min2} - ${max}`);
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/subset.js
var require_subset = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/subset.js"(exports, module) {
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies2 = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom)
        return true;
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER:
        for (const simpleSub of sub.set) {
          for (const simpleDom of dom.set) {
            const isSub = simpleSubset(simpleSub, simpleDom, options);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub)
              continue OUTER;
          }
          if (sawNonNull)
            return false;
        }
      return true;
    };
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom)
        return true;
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY)
          return true;
        else if (options.includePrerelease)
          sub = [new Comparator(">=0.0.0-0")];
        else
          sub = [new Comparator(">=0.0.0")];
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease)
          return true;
        else
          dom = [new Comparator(">=0.0.0")];
      }
      const eqSet = new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=")
          gt = higherGT(gt, c, options);
        else if (c.operator === "<" || c.operator === "<=")
          lt = lowerLT(lt, c, options);
        else
          eqSet.add(c.semver);
      }
      if (eqSet.size > 1)
        return null;
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0)
          return null;
        else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<="))
          return null;
      }
      for (const eq of eqSet) {
        if (gt && !satisfies2(eq, String(gt), options))
          return null;
        if (lt && !satisfies2(eq, String(lt), options))
          return null;
        for (const c of dom) {
          if (!satisfies2(eq, String(c), options))
            return false;
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt)
              return false;
          } else if (gt.operator === ">=" && !satisfies2(gt.semver, String(c), options))
            return false;
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt)
              return false;
          } else if (lt.operator === "<=" && !satisfies2(lt.semver, String(c), options))
            return false;
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0)
          return false;
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0)
        return false;
      if (lt && hasDomGT && !gt && gtltComp !== 0)
        return false;
      if (needDomGTPre || needDomLTPre)
        return false;
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a)
        return b;
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a)
        return b;
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module.exports = subset;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/index.js
var require_semver2 = _chunkKRCSYS75js.__commonJS.call(void 0, {
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/index.js"(exports, module) {
    var internalRe = require_re();
    module.exports = {
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: require_constants().SEMVER_SPEC_VERSION,
      SemVer: require_semver(),
      compareIdentifiers: require_identifiers().compareIdentifiers,
      rcompareIdentifiers: require_identifiers().rcompareIdentifiers,
      parse: require_parse(),
      valid: require_valid(),
      clean: require_clean(),
      inc: require_inc(),
      diff: require_diff(),
      major: require_major(),
      minor: require_minor(),
      patch: require_patch(),
      prerelease: require_prerelease(),
      compare: require_compare(),
      rcompare: require_rcompare(),
      compareLoose: require_compare_loose(),
      compareBuild: require_compare_build(),
      sort: require_sort(),
      rsort: require_rsort(),
      gt: require_gt(),
      lt: require_lt(),
      eq: require_eq(),
      neq: require_neq(),
      gte: require_gte(),
      lte: require_lte(),
      cmp: require_cmp(),
      coerce: require_coerce(),
      Comparator: require_comparator(),
      Range: require_range(),
      satisfies: require_satisfies(),
      toComparators: require_to_comparators(),
      maxSatisfying: require_max_satisfying(),
      minSatisfying: require_min_satisfying(),
      minVersion: require_min_version(),
      validRange: require_valid2(),
      outside: require_outside(),
      gtr: require_gtr(),
      ltr: require_ltr(),
      intersects: require_intersects(),
      simplifyRange: require_simplify(),
      subset: require_subset()
    };
  }
});

// package.json
var version = "0.22.7";

// node/themes.ts
var import_ni = _chunkKRCSYS75js.__toModule.call(void 0, require_dist());
var import_semver = _chunkKRCSYS75js.__toModule.call(void 0, require_semver2());
var _prompts = require('prompts'); var _prompts2 = _interopRequireDefault2(_prompts);
var _isinstalledglobally = require('is-installed-globally'); var _isinstalledglobally2 = _interopRequireDefault2(_isinstalledglobally);
var _kolorist = require('kolorist');
var _fsextra = require('fs-extra'); var _fsextra2 = _interopRequireDefault2(_fsextra);

// node/options.ts
var _path3 = require('path');
var _utils = require('@antfu/utils');



var _fs3 = require('@slidev/parser/fs');
var _debug2 = require('debug'); var _debug3 = _interopRequireDefault2(_debug2);
var debug = _debug3.default.call(void 0, "slidev:options");
function getClientRoot() {
  return _path3.dirname.call(void 0, _chunkKRCSYS75js.resolveImportPath.call(void 0, "@slidev/client/package.json", true));
}
function getCLIRoot() {
  return _path3.resolve.call(void 0, __dirname, "..");
}
function isPath(name) {
  return name.startsWith("/") || /^\.\.?[\/\\]/.test(name);
}
function getThemeRoots(name, entry) {
  if (!name)
    return [];
  if (isPath(name)) {
    return [
      _path3.resolve.call(void 0, _path3.dirname.call(void 0, entry), name)
    ];
  } else {
    return [
      _path3.dirname.call(void 0, _chunkKRCSYS75js.resolveImportPath.call(void 0, `${name}/package.json`, true))
    ];
  }
}
async function resolveOptions(options, mode, promptForInstallation = true) {
  const {
    entry: rawEntry = "slides.md",
    userRoot = process.cwd()
  } = options;
  const entry = _path3.resolve.call(void 0, userRoot, rawEntry);
  const data = await _fs3.load.call(void 0, entry);
  const theme = resolveThemeName(options.theme || data.config.theme);
  if (promptForInstallation) {
    if (await promptForThemeInstallation(theme) === false)
      process.exit(1);
  } else {
    if (!packageExists(theme)) {
      console.error(`Theme "${theme}" not found, have you installed it?`);
      process.exit(1);
    }
  }
  const clientRoot = getClientRoot();
  const cliRoot = getCLIRoot();
  const themeRoots = getThemeRoots(theme, entry);
  const roots = _utils.uniq.call(void 0, [clientRoot, ...themeRoots, userRoot]);
  if (themeRoots.length) {
    const themeMeta = await getThemeMeta(theme, _path3.join.call(void 0, themeRoots[0], "package.json"));
    data.themeMeta = themeMeta;
    if (themeMeta)
      data.config = _fs3.resolveConfig.call(void 0, data.headmatter, themeMeta);
  }
  debug({
    config: data.config,
    mode,
    entry,
    theme,
    userRoot,
    clientRoot,
    cliRoot,
    themeRoots,
    roots
  });
  return {
    data,
    mode,
    entry,
    theme,
    userRoot,
    clientRoot,
    cliRoot,
    themeRoots,
    roots
  };
}

// node/themes.ts
var officialThemes = {
  "none": "",
  "default": "@slidev/theme-default",
  "seriph": "@slidev/theme-seriph",
  "apple-basic": "@slidev/theme-apple-basic",
  "shibainu": "@slidev/theme-shibainu",
  "bricks": "@slidev/theme-bricks"
};
function packageExists(name) {
  if (_chunkKRCSYS75js.resolveImportPath.call(void 0, `${name}/package.json`))
    return true;
  return false;
}
async function getThemeMeta(name, path) {
  if (!_fsextra2.default.existsSync(path))
    return {};
  if (path) {
    const { slidev = {}, engines = {} } = await _fsextra2.default.readJSON(path);
    if (engines.slidev && !(0, import_semver.satisfies)(version, engines.slidev))
      throw new Error(`[slidev] theme "${name}" requires Slidev version range "${engines.slidev}" but found "${version}"`);
    return slidev;
  }
  return void 0;
}
function resolveThemeName(name) {
  if (!name || name === "none")
    return "";
  if (name.startsWith("@slidev/theme-") || name.startsWith("slidev-theme-"))
    return name;
  if (isPath(name))
    return name;
  if (packageExists(`@slidev/theme-${name}`))
    return `@slidev/theme-${name}`;
  if (packageExists(`slidev-theme-${name}`))
    return `slidev-theme-${name}`;
  if (officialThemes[name] != null)
    return officialThemes[name];
  return `slidev-theme-${name}`;
}
async function promptForThemeInstallation(name) {
  name = resolveThemeName(name);
  if (!name)
    return name;
  if (isPath(name) || packageExists(name))
    return name;
  const { confirm } = await _prompts2.default.call(void 0, {
    name: "confirm",
    initial: "Y",
    type: "confirm",
    message: `The theme "${name}" was not found ${_kolorist.underline.call(void 0, _isinstalledglobally2.default ? "globally" : "in your project")}, do you want to install it now?`
  });
  if (!confirm)
    return false;
  if (_isinstalledglobally2.default)
    await (0, import_ni.run)(import_ni.parseNi, ["-g", name]);
  else
    await (0, import_ni.run)(import_ni.parseNi, [name]);
  return name;
}










exports.version = version; exports.packageExists = packageExists; exports.resolveThemeName = resolveThemeName; exports.getClientRoot = getClientRoot; exports.getCLIRoot = getCLIRoot; exports.isPath = isPath; exports.getThemeRoots = getThemeRoots; exports.resolveOptions = resolveOptions;
